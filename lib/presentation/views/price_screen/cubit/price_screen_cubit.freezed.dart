// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'price_screen_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PriceScreenState {
  PriceScreenProps get props => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PriceScreenProps props) initial,
    required TResult Function(PriceScreenProps props) loading,
    required TResult Function(PriceScreenProps props) completed,
    required TResult Function(PriceScreenProps props, Failure failure) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PriceInitial value) initial,
    required TResult Function(PriceLoading value) loading,
    required TResult Function(PriceCompleted value) completed,
    required TResult Function(PriceError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PriceScreenStateCopyWith<PriceScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PriceScreenStateCopyWith<$Res> {
  factory $PriceScreenStateCopyWith(
          PriceScreenState value, $Res Function(PriceScreenState) then) =
      _$PriceScreenStateCopyWithImpl<$Res>;
  $Res call({PriceScreenProps props});

  $PriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$PriceScreenStateCopyWithImpl<$Res>
    implements $PriceScreenStateCopyWith<$Res> {
  _$PriceScreenStateCopyWithImpl(this._value, this._then);

  final PriceScreenState _value;
  // ignore: unused_field
  final $Res Function(PriceScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as PriceScreenProps,
    ));
  }

  @override
  $PriceScreenPropsCopyWith<$Res> get props {
    return $PriceScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class _$$PriceInitialCopyWith<$Res>
    implements $PriceScreenStateCopyWith<$Res> {
  factory _$$PriceInitialCopyWith(
          _$PriceInitial value, $Res Function(_$PriceInitial) then) =
      __$$PriceInitialCopyWithImpl<$Res>;
  @override
  $Res call({PriceScreenProps props});

  @override
  $PriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$PriceInitialCopyWithImpl<$Res>
    extends _$PriceScreenStateCopyWithImpl<$Res>
    implements _$$PriceInitialCopyWith<$Res> {
  __$$PriceInitialCopyWithImpl(
      _$PriceInitial _value, $Res Function(_$PriceInitial) _then)
      : super(_value, (v) => _then(v as _$PriceInitial));

  @override
  _$PriceInitial get _value => super._value as _$PriceInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$PriceInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as PriceScreenProps,
    ));
  }
}

/// @nodoc

class _$PriceInitial implements PriceInitial {
  const _$PriceInitial({required this.props});

  @override
  final PriceScreenProps props;

  @override
  String toString() {
    return 'PriceScreenState.initial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PriceInitial &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$PriceInitialCopyWith<_$PriceInitial> get copyWith =>
      __$$PriceInitialCopyWithImpl<_$PriceInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PriceScreenProps props) initial,
    required TResult Function(PriceScreenProps props) loading,
    required TResult Function(PriceScreenProps props) completed,
    required TResult Function(PriceScreenProps props, Failure failure) error,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PriceInitial value) initial,
    required TResult Function(PriceLoading value) loading,
    required TResult Function(PriceCompleted value) completed,
    required TResult Function(PriceError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class PriceInitial implements PriceScreenState {
  const factory PriceInitial({required final PriceScreenProps props}) =
      _$PriceInitial;

  @override
  PriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$PriceInitialCopyWith<_$PriceInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PriceLoadingCopyWith<$Res>
    implements $PriceScreenStateCopyWith<$Res> {
  factory _$$PriceLoadingCopyWith(
          _$PriceLoading value, $Res Function(_$PriceLoading) then) =
      __$$PriceLoadingCopyWithImpl<$Res>;
  @override
  $Res call({PriceScreenProps props});

  @override
  $PriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$PriceLoadingCopyWithImpl<$Res>
    extends _$PriceScreenStateCopyWithImpl<$Res>
    implements _$$PriceLoadingCopyWith<$Res> {
  __$$PriceLoadingCopyWithImpl(
      _$PriceLoading _value, $Res Function(_$PriceLoading) _then)
      : super(_value, (v) => _then(v as _$PriceLoading));

  @override
  _$PriceLoading get _value => super._value as _$PriceLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$PriceLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as PriceScreenProps,
    ));
  }
}

/// @nodoc

class _$PriceLoading implements PriceLoading {
  const _$PriceLoading({required this.props});

  @override
  final PriceScreenProps props;

  @override
  String toString() {
    return 'PriceScreenState.loading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PriceLoading &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$PriceLoadingCopyWith<_$PriceLoading> get copyWith =>
      __$$PriceLoadingCopyWithImpl<_$PriceLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PriceScreenProps props) initial,
    required TResult Function(PriceScreenProps props) loading,
    required TResult Function(PriceScreenProps props) completed,
    required TResult Function(PriceScreenProps props, Failure failure) error,
  }) {
    return loading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
  }) {
    return loading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PriceInitial value) initial,
    required TResult Function(PriceLoading value) loading,
    required TResult Function(PriceCompleted value) completed,
    required TResult Function(PriceError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PriceLoading implements PriceScreenState {
  const factory PriceLoading({required final PriceScreenProps props}) =
      _$PriceLoading;

  @override
  PriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$PriceLoadingCopyWith<_$PriceLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PriceCompletedCopyWith<$Res>
    implements $PriceScreenStateCopyWith<$Res> {
  factory _$$PriceCompletedCopyWith(
          _$PriceCompleted value, $Res Function(_$PriceCompleted) then) =
      __$$PriceCompletedCopyWithImpl<$Res>;
  @override
  $Res call({PriceScreenProps props});

  @override
  $PriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$PriceCompletedCopyWithImpl<$Res>
    extends _$PriceScreenStateCopyWithImpl<$Res>
    implements _$$PriceCompletedCopyWith<$Res> {
  __$$PriceCompletedCopyWithImpl(
      _$PriceCompleted _value, $Res Function(_$PriceCompleted) _then)
      : super(_value, (v) => _then(v as _$PriceCompleted));

  @override
  _$PriceCompleted get _value => super._value as _$PriceCompleted;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$PriceCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as PriceScreenProps,
    ));
  }
}

/// @nodoc

class _$PriceCompleted implements PriceCompleted {
  const _$PriceCompleted({required this.props});

  @override
  final PriceScreenProps props;

  @override
  String toString() {
    return 'PriceScreenState.completed(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PriceCompleted &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$PriceCompletedCopyWith<_$PriceCompleted> get copyWith =>
      __$$PriceCompletedCopyWithImpl<_$PriceCompleted>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PriceScreenProps props) initial,
    required TResult Function(PriceScreenProps props) loading,
    required TResult Function(PriceScreenProps props) completed,
    required TResult Function(PriceScreenProps props, Failure failure) error,
  }) {
    return completed(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
  }) {
    return completed?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PriceInitial value) initial,
    required TResult Function(PriceLoading value) loading,
    required TResult Function(PriceCompleted value) completed,
    required TResult Function(PriceError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class PriceCompleted implements PriceScreenState {
  const factory PriceCompleted({required final PriceScreenProps props}) =
      _$PriceCompleted;

  @override
  PriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$PriceCompletedCopyWith<_$PriceCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PriceErrorCopyWith<$Res>
    implements $PriceScreenStateCopyWith<$Res> {
  factory _$$PriceErrorCopyWith(
          _$PriceError value, $Res Function(_$PriceError) then) =
      __$$PriceErrorCopyWithImpl<$Res>;
  @override
  $Res call({PriceScreenProps props, Failure failure});

  @override
  $PriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$PriceErrorCopyWithImpl<$Res>
    extends _$PriceScreenStateCopyWithImpl<$Res>
    implements _$$PriceErrorCopyWith<$Res> {
  __$$PriceErrorCopyWithImpl(
      _$PriceError _value, $Res Function(_$PriceError) _then)
      : super(_value, (v) => _then(v as _$PriceError));

  @override
  _$PriceError get _value => super._value as _$PriceError;

  @override
  $Res call({
    Object? props = freezed,
    Object? failure = freezed,
  }) {
    return _then(_$PriceError(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as PriceScreenProps,
      failure: failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure,
    ));
  }
}

/// @nodoc

class _$PriceError implements PriceError {
  const _$PriceError({required this.props, required this.failure});

  @override
  final PriceScreenProps props;
  @override
  final Failure failure;

  @override
  String toString() {
    return 'PriceScreenState.error(props: $props, failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PriceError &&
            const DeepCollectionEquality().equals(other.props, props) &&
            const DeepCollectionEquality().equals(other.failure, failure));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(props),
      const DeepCollectionEquality().hash(failure));

  @JsonKey(ignore: true)
  @override
  _$$PriceErrorCopyWith<_$PriceError> get copyWith =>
      __$$PriceErrorCopyWithImpl<_$PriceError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PriceScreenProps props) initial,
    required TResult Function(PriceScreenProps props) loading,
    required TResult Function(PriceScreenProps props) completed,
    required TResult Function(PriceScreenProps props, Failure failure) error,
  }) {
    return error(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
  }) {
    return error?.call(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PriceScreenProps props)? initial,
    TResult Function(PriceScreenProps props)? loading,
    TResult Function(PriceScreenProps props)? completed,
    TResult Function(PriceScreenProps props, Failure failure)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(props, failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PriceInitial value) initial,
    required TResult Function(PriceLoading value) loading,
    required TResult Function(PriceCompleted value) completed,
    required TResult Function(PriceError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PriceInitial value)? initial,
    TResult Function(PriceLoading value)? loading,
    TResult Function(PriceCompleted value)? completed,
    TResult Function(PriceError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PriceError implements PriceScreenState {
  const factory PriceError(
      {required final PriceScreenProps props,
      required final Failure failure}) = _$PriceError;

  @override
  PriceScreenProps get props => throw _privateConstructorUsedError;
  Failure get failure => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$PriceErrorCopyWith<_$PriceError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PriceScreenProps {
  Price get price => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PriceScreenPropsCopyWith<PriceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PriceScreenPropsCopyWith<$Res> {
  factory $PriceScreenPropsCopyWith(
          PriceScreenProps value, $Res Function(PriceScreenProps) then) =
      _$PriceScreenPropsCopyWithImpl<$Res>;
  $Res call({Price price});

  $PriceCopyWith<$Res> get price;
}

/// @nodoc
class _$PriceScreenPropsCopyWithImpl<$Res>
    implements $PriceScreenPropsCopyWith<$Res> {
  _$PriceScreenPropsCopyWithImpl(this._value, this._then);

  final PriceScreenProps _value;
  // ignore: unused_field
  final $Res Function(PriceScreenProps) _then;

  @override
  $Res call({
    Object? price = freezed,
  }) {
    return _then(_value.copyWith(
      price: price == freezed
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as Price,
    ));
  }

  @override
  $PriceCopyWith<$Res> get price {
    return $PriceCopyWith<$Res>(_value.price, (value) {
      return _then(_value.copyWith(price: value));
    });
  }
}

/// @nodoc
abstract class _$$_PriceScreenPropsCopyWith<$Res>
    implements $PriceScreenPropsCopyWith<$Res> {
  factory _$$_PriceScreenPropsCopyWith(
          _$_PriceScreenProps value, $Res Function(_$_PriceScreenProps) then) =
      __$$_PriceScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call({Price price});

  @override
  $PriceCopyWith<$Res> get price;
}

/// @nodoc
class __$$_PriceScreenPropsCopyWithImpl<$Res>
    extends _$PriceScreenPropsCopyWithImpl<$Res>
    implements _$$_PriceScreenPropsCopyWith<$Res> {
  __$$_PriceScreenPropsCopyWithImpl(
      _$_PriceScreenProps _value, $Res Function(_$_PriceScreenProps) _then)
      : super(_value, (v) => _then(v as _$_PriceScreenProps));

  @override
  _$_PriceScreenProps get _value => super._value as _$_PriceScreenProps;

  @override
  $Res call({
    Object? price = freezed,
  }) {
    return _then(_$_PriceScreenProps(
      price: price == freezed
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as Price,
    ));
  }
}

/// @nodoc

class _$_PriceScreenProps implements _PriceScreenProps {
  const _$_PriceScreenProps({required this.price});

  @override
  final Price price;

  @override
  String toString() {
    return 'PriceScreenProps(price: $price)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PriceScreenProps &&
            const DeepCollectionEquality().equals(other.price, price));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(price));

  @JsonKey(ignore: true)
  @override
  _$$_PriceScreenPropsCopyWith<_$_PriceScreenProps> get copyWith =>
      __$$_PriceScreenPropsCopyWithImpl<_$_PriceScreenProps>(this, _$identity);
}

abstract class _PriceScreenProps implements PriceScreenProps {
  const factory _PriceScreenProps({required final Price price}) =
      _$_PriceScreenProps;

  @override
  Price get price => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_PriceScreenPropsCopyWith<_$_PriceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'register_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RegisterScreenEventTearOff {
  const _$RegisterScreenEventTearOff();

  _RSEStarted started() {
    return const _RSEStarted();
  }

  _RSEIdle idle() {
    return const _RSEIdle();
  }

  _RSEContinuePressed continuePressed() {
    return const _RSEContinuePressed();
  }

  _RSEToggleVisible toggleInfoTileVisibility() {
    return const _RSEToggleVisible();
  }
}

/// @nodoc
const $RegisterScreenEvent = _$RegisterScreenEventTearOff();

/// @nodoc
mixin _$RegisterScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSEStarted value) started,
    required TResult Function(_RSEIdle value) idle,
    required TResult Function(_RSEContinuePressed value) continuePressed,
    required TResult Function(_RSEToggleVisible value) toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegisterScreenEventCopyWith<$Res> {
  factory $RegisterScreenEventCopyWith(
          RegisterScreenEvent value, $Res Function(RegisterScreenEvent) then) =
      _$RegisterScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$RegisterScreenEventCopyWithImpl<$Res>
    implements $RegisterScreenEventCopyWith<$Res> {
  _$RegisterScreenEventCopyWithImpl(this._value, this._then);

  final RegisterScreenEvent _value;
  // ignore: unused_field
  final $Res Function(RegisterScreenEvent) _then;
}

/// @nodoc
abstract class _$RSEStartedCopyWith<$Res> {
  factory _$RSEStartedCopyWith(
          _RSEStarted value, $Res Function(_RSEStarted) then) =
      __$RSEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$RSEStartedCopyWithImpl<$Res>
    extends _$RegisterScreenEventCopyWithImpl<$Res>
    implements _$RSEStartedCopyWith<$Res> {
  __$RSEStartedCopyWithImpl(
      _RSEStarted _value, $Res Function(_RSEStarted) _then)
      : super(_value, (v) => _then(v as _RSEStarted));

  @override
  _RSEStarted get _value => super._value as _RSEStarted;
}

/// @nodoc

class _$_RSEStarted implements _RSEStarted {
  const _$_RSEStarted();

  @override
  String toString() {
    return 'RegisterScreenEvent.started()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _RSEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSEStarted value) started,
    required TResult Function(_RSEIdle value) idle,
    required TResult Function(_RSEContinuePressed value) continuePressed,
    required TResult Function(_RSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _RSEStarted implements RegisterScreenEvent {
  const factory _RSEStarted() = _$_RSEStarted;
}

/// @nodoc
abstract class _$RSEIdleCopyWith<$Res> {
  factory _$RSEIdleCopyWith(_RSEIdle value, $Res Function(_RSEIdle) then) =
      __$RSEIdleCopyWithImpl<$Res>;
}

/// @nodoc
class __$RSEIdleCopyWithImpl<$Res>
    extends _$RegisterScreenEventCopyWithImpl<$Res>
    implements _$RSEIdleCopyWith<$Res> {
  __$RSEIdleCopyWithImpl(_RSEIdle _value, $Res Function(_RSEIdle) _then)
      : super(_value, (v) => _then(v as _RSEIdle));

  @override
  _RSEIdle get _value => super._value as _RSEIdle;
}

/// @nodoc

class _$_RSEIdle implements _RSEIdle {
  const _$_RSEIdle();

  @override
  String toString() {
    return 'RegisterScreenEvent.idle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _RSEIdle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSEStarted value) started,
    required TResult Function(_RSEIdle value) idle,
    required TResult Function(_RSEContinuePressed value) continuePressed,
    required TResult Function(_RSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _RSEIdle implements RegisterScreenEvent {
  const factory _RSEIdle() = _$_RSEIdle;
}

/// @nodoc
abstract class _$RSEContinuePressedCopyWith<$Res> {
  factory _$RSEContinuePressedCopyWith(
          _RSEContinuePressed value, $Res Function(_RSEContinuePressed) then) =
      __$RSEContinuePressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$RSEContinuePressedCopyWithImpl<$Res>
    extends _$RegisterScreenEventCopyWithImpl<$Res>
    implements _$RSEContinuePressedCopyWith<$Res> {
  __$RSEContinuePressedCopyWithImpl(
      _RSEContinuePressed _value, $Res Function(_RSEContinuePressed) _then)
      : super(_value, (v) => _then(v as _RSEContinuePressed));

  @override
  _RSEContinuePressed get _value => super._value as _RSEContinuePressed;
}

/// @nodoc

class _$_RSEContinuePressed implements _RSEContinuePressed {
  const _$_RSEContinuePressed();

  @override
  String toString() {
    return 'RegisterScreenEvent.continuePressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _RSEContinuePressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return continuePressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return continuePressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (continuePressed != null) {
      return continuePressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSEStarted value) started,
    required TResult Function(_RSEIdle value) idle,
    required TResult Function(_RSEContinuePressed value) continuePressed,
    required TResult Function(_RSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return continuePressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return continuePressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (continuePressed != null) {
      return continuePressed(this);
    }
    return orElse();
  }
}

abstract class _RSEContinuePressed implements RegisterScreenEvent {
  const factory _RSEContinuePressed() = _$_RSEContinuePressed;
}

/// @nodoc
abstract class _$RSEToggleVisibleCopyWith<$Res> {
  factory _$RSEToggleVisibleCopyWith(
          _RSEToggleVisible value, $Res Function(_RSEToggleVisible) then) =
      __$RSEToggleVisibleCopyWithImpl<$Res>;
}

/// @nodoc
class __$RSEToggleVisibleCopyWithImpl<$Res>
    extends _$RegisterScreenEventCopyWithImpl<$Res>
    implements _$RSEToggleVisibleCopyWith<$Res> {
  __$RSEToggleVisibleCopyWithImpl(
      _RSEToggleVisible _value, $Res Function(_RSEToggleVisible) _then)
      : super(_value, (v) => _then(v as _RSEToggleVisible));

  @override
  _RSEToggleVisible get _value => super._value as _RSEToggleVisible;
}

/// @nodoc

class _$_RSEToggleVisible implements _RSEToggleVisible {
  const _$_RSEToggleVisible();

  @override
  String toString() {
    return 'RegisterScreenEvent.toggleInfoTileVisibility()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _RSEToggleVisible);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (toggleInfoTileVisibility != null) {
      return toggleInfoTileVisibility();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSEStarted value) started,
    required TResult Function(_RSEIdle value) idle,
    required TResult Function(_RSEContinuePressed value) continuePressed,
    required TResult Function(_RSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSEStarted value)? started,
    TResult Function(_RSEIdle value)? idle,
    TResult Function(_RSEContinuePressed value)? continuePressed,
    TResult Function(_RSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (toggleInfoTileVisibility != null) {
      return toggleInfoTileVisibility(this);
    }
    return orElse();
  }
}

abstract class _RSEToggleVisible implements RegisterScreenEvent {
  const factory _RSEToggleVisible() = _$_RSEToggleVisible;
}

/// @nodoc
class _$RegisterScreenStateTearOff {
  const _$RegisterScreenStateTearOff();

  _RSSInitial initial(RegisterScreenProps props) {
    return _RSSInitial(
      props,
    );
  }

  _RSSLoading loading(RegisterScreenProps props) {
    return _RSSLoading(
      props,
    );
  }

  _RSSIdle idle(RegisterScreenProps props) {
    return _RSSIdle(
      props,
    );
  }
}

/// @nodoc
const $RegisterScreenState = _$RegisterScreenStateTearOff();

/// @nodoc
mixin _$RegisterScreenState {
  RegisterScreenProps get props => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegisterScreenProps props) initial,
    required TResult Function(RegisterScreenProps props) loading,
    required TResult Function(RegisterScreenProps props) idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSSInitial value) initial,
    required TResult Function(_RSSLoading value) loading,
    required TResult Function(_RSSIdle value) idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RegisterScreenStateCopyWith<RegisterScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegisterScreenStateCopyWith<$Res> {
  factory $RegisterScreenStateCopyWith(
          RegisterScreenState value, $Res Function(RegisterScreenState) then) =
      _$RegisterScreenStateCopyWithImpl<$Res>;
  $Res call({RegisterScreenProps props});

  $RegisterScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$RegisterScreenStateCopyWithImpl<$Res>
    implements $RegisterScreenStateCopyWith<$Res> {
  _$RegisterScreenStateCopyWithImpl(this._value, this._then);

  final RegisterScreenState _value;
  // ignore: unused_field
  final $Res Function(RegisterScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as RegisterScreenProps,
    ));
  }

  @override
  $RegisterScreenPropsCopyWith<$Res> get props {
    return $RegisterScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class _$RSSInitialCopyWith<$Res>
    implements $RegisterScreenStateCopyWith<$Res> {
  factory _$RSSInitialCopyWith(
          _RSSInitial value, $Res Function(_RSSInitial) then) =
      __$RSSInitialCopyWithImpl<$Res>;
  @override
  $Res call({RegisterScreenProps props});

  @override
  $RegisterScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$RSSInitialCopyWithImpl<$Res>
    extends _$RegisterScreenStateCopyWithImpl<$Res>
    implements _$RSSInitialCopyWith<$Res> {
  __$RSSInitialCopyWithImpl(
      _RSSInitial _value, $Res Function(_RSSInitial) _then)
      : super(_value, (v) => _then(v as _RSSInitial));

  @override
  _RSSInitial get _value => super._value as _RSSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_RSSInitial(
      props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as RegisterScreenProps,
    ));
  }
}

/// @nodoc

class _$_RSSInitial implements _RSSInitial {
  const _$_RSSInitial(this.props);

  @override
  final RegisterScreenProps props;

  @override
  String toString() {
    return 'RegisterScreenState.initial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RSSInitial &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$RSSInitialCopyWith<_RSSInitial> get copyWith =>
      __$RSSInitialCopyWithImpl<_RSSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegisterScreenProps props) initial,
    required TResult Function(RegisterScreenProps props) loading,
    required TResult Function(RegisterScreenProps props) idle,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSSInitial value) initial,
    required TResult Function(_RSSLoading value) loading,
    required TResult Function(_RSSIdle value) idle,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _RSSInitial implements RegisterScreenState {
  const factory _RSSInitial(RegisterScreenProps props) = _$_RSSInitial;

  @override
  RegisterScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$RSSInitialCopyWith<_RSSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$RSSLoadingCopyWith<$Res>
    implements $RegisterScreenStateCopyWith<$Res> {
  factory _$RSSLoadingCopyWith(
          _RSSLoading value, $Res Function(_RSSLoading) then) =
      __$RSSLoadingCopyWithImpl<$Res>;
  @override
  $Res call({RegisterScreenProps props});

  @override
  $RegisterScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$RSSLoadingCopyWithImpl<$Res>
    extends _$RegisterScreenStateCopyWithImpl<$Res>
    implements _$RSSLoadingCopyWith<$Res> {
  __$RSSLoadingCopyWithImpl(
      _RSSLoading _value, $Res Function(_RSSLoading) _then)
      : super(_value, (v) => _then(v as _RSSLoading));

  @override
  _RSSLoading get _value => super._value as _RSSLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_RSSLoading(
      props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as RegisterScreenProps,
    ));
  }
}

/// @nodoc

class _$_RSSLoading implements _RSSLoading {
  const _$_RSSLoading(this.props);

  @override
  final RegisterScreenProps props;

  @override
  String toString() {
    return 'RegisterScreenState.loading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RSSLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$RSSLoadingCopyWith<_RSSLoading> get copyWith =>
      __$RSSLoadingCopyWithImpl<_RSSLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegisterScreenProps props) initial,
    required TResult Function(RegisterScreenProps props) loading,
    required TResult Function(RegisterScreenProps props) idle,
  }) {
    return loading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
  }) {
    return loading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSSInitial value) initial,
    required TResult Function(_RSSLoading value) loading,
    required TResult Function(_RSSIdle value) idle,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _RSSLoading implements RegisterScreenState {
  const factory _RSSLoading(RegisterScreenProps props) = _$_RSSLoading;

  @override
  RegisterScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$RSSLoadingCopyWith<_RSSLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$RSSIdleCopyWith<$Res>
    implements $RegisterScreenStateCopyWith<$Res> {
  factory _$RSSIdleCopyWith(_RSSIdle value, $Res Function(_RSSIdle) then) =
      __$RSSIdleCopyWithImpl<$Res>;
  @override
  $Res call({RegisterScreenProps props});

  @override
  $RegisterScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$RSSIdleCopyWithImpl<$Res>
    extends _$RegisterScreenStateCopyWithImpl<$Res>
    implements _$RSSIdleCopyWith<$Res> {
  __$RSSIdleCopyWithImpl(_RSSIdle _value, $Res Function(_RSSIdle) _then)
      : super(_value, (v) => _then(v as _RSSIdle));

  @override
  _RSSIdle get _value => super._value as _RSSIdle;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_RSSIdle(
      props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as RegisterScreenProps,
    ));
  }
}

/// @nodoc

class _$_RSSIdle implements _RSSIdle {
  const _$_RSSIdle(this.props);

  @override
  final RegisterScreenProps props;

  @override
  String toString() {
    return 'RegisterScreenState.idle(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RSSIdle &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$RSSIdleCopyWith<_RSSIdle> get copyWith =>
      __$RSSIdleCopyWithImpl<_RSSIdle>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RegisterScreenProps props) initial,
    required TResult Function(RegisterScreenProps props) loading,
    required TResult Function(RegisterScreenProps props) idle,
  }) {
    return idle(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
  }) {
    return idle?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RegisterScreenProps props)? initial,
    TResult Function(RegisterScreenProps props)? loading,
    TResult Function(RegisterScreenProps props)? idle,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_RSSInitial value) initial,
    required TResult Function(_RSSLoading value) loading,
    required TResult Function(_RSSIdle value) idle,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_RSSInitial value)? initial,
    TResult Function(_RSSLoading value)? loading,
    TResult Function(_RSSIdle value)? idle,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _RSSIdle implements RegisterScreenState {
  const factory _RSSIdle(RegisterScreenProps props) = _$_RSSIdle;

  @override
  RegisterScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$RSSIdleCopyWith<_RSSIdle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$RegisterScreenPropsTearOff {
  const _$RegisterScreenPropsTearOff();

  _RegisterScreenProps call({required bool isInfoTileVisible}) {
    return _RegisterScreenProps(
      isInfoTileVisible: isInfoTileVisible,
    );
  }
}

/// @nodoc
const $RegisterScreenProps = _$RegisterScreenPropsTearOff();

/// @nodoc
mixin _$RegisterScreenProps {
  bool get isInfoTileVisible => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RegisterScreenPropsCopyWith<RegisterScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegisterScreenPropsCopyWith<$Res> {
  factory $RegisterScreenPropsCopyWith(
          RegisterScreenProps value, $Res Function(RegisterScreenProps) then) =
      _$RegisterScreenPropsCopyWithImpl<$Res>;
  $Res call({bool isInfoTileVisible});
}

/// @nodoc
class _$RegisterScreenPropsCopyWithImpl<$Res>
    implements $RegisterScreenPropsCopyWith<$Res> {
  _$RegisterScreenPropsCopyWithImpl(this._value, this._then);

  final RegisterScreenProps _value;
  // ignore: unused_field
  final $Res Function(RegisterScreenProps) _then;

  @override
  $Res call({
    Object? isInfoTileVisible = freezed,
  }) {
    return _then(_value.copyWith(
      isInfoTileVisible: isInfoTileVisible == freezed
          ? _value.isInfoTileVisible
          : isInfoTileVisible // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$RegisterScreenPropsCopyWith<$Res>
    implements $RegisterScreenPropsCopyWith<$Res> {
  factory _$RegisterScreenPropsCopyWith(_RegisterScreenProps value,
          $Res Function(_RegisterScreenProps) then) =
      __$RegisterScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call({bool isInfoTileVisible});
}

/// @nodoc
class __$RegisterScreenPropsCopyWithImpl<$Res>
    extends _$RegisterScreenPropsCopyWithImpl<$Res>
    implements _$RegisterScreenPropsCopyWith<$Res> {
  __$RegisterScreenPropsCopyWithImpl(
      _RegisterScreenProps _value, $Res Function(_RegisterScreenProps) _then)
      : super(_value, (v) => _then(v as _RegisterScreenProps));

  @override
  _RegisterScreenProps get _value => super._value as _RegisterScreenProps;

  @override
  $Res call({
    Object? isInfoTileVisible = freezed,
  }) {
    return _then(_RegisterScreenProps(
      isInfoTileVisible: isInfoTileVisible == freezed
          ? _value.isInfoTileVisible
          : isInfoTileVisible // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_RegisterScreenProps implements _RegisterScreenProps {
  const _$_RegisterScreenProps({required this.isInfoTileVisible});

  @override
  final bool isInfoTileVisible;

  @override
  String toString() {
    return 'RegisterScreenProps(isInfoTileVisible: $isInfoTileVisible)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _RegisterScreenProps &&
            (identical(other.isInfoTileVisible, isInfoTileVisible) ||
                other.isInfoTileVisible == isInfoTileVisible));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isInfoTileVisible);

  @JsonKey(ignore: true)
  @override
  _$RegisterScreenPropsCopyWith<_RegisterScreenProps> get copyWith =>
      __$RegisterScreenPropsCopyWithImpl<_RegisterScreenProps>(
          this, _$identity);
}

abstract class _RegisterScreenProps implements RegisterScreenProps {
  const factory _RegisterScreenProps({required bool isInfoTileVisible}) =
      _$_RegisterScreenProps;

  @override
  bool get isInfoTileVisible;
  @override
  @JsonKey(ignore: true)
  _$RegisterScreenPropsCopyWith<_RegisterScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

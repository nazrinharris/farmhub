// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'produce_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ProduceScreenEventTearOff {
  const _$ProduceScreenEventTearOff();

  _PSEStarted started() {
    return const _PSEStarted();
  }

  _PSETabChanged tabChanged() {
    return const _PSETabChanged();
  }

  _PSEGetAggregatePrices getAggregatePrices() {
    return const _PSEGetAggregatePrices();
  }
}

/// @nodoc
const $ProduceScreenEvent = _$ProduceScreenEventTearOff();

/// @nodoc
mixin _$ProduceScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() tabChanged,
    required TResult Function() getAggregatePrices,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSEStarted value) started,
    required TResult Function(_PSETabChanged value) tabChanged,
    required TResult Function(_PSEGetAggregatePrices value) getAggregatePrices,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProduceScreenEventCopyWith<$Res> {
  factory $ProduceScreenEventCopyWith(
          ProduceScreenEvent value, $Res Function(ProduceScreenEvent) then) =
      _$ProduceScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$ProduceScreenEventCopyWithImpl<$Res>
    implements $ProduceScreenEventCopyWith<$Res> {
  _$ProduceScreenEventCopyWithImpl(this._value, this._then);

  final ProduceScreenEvent _value;
  // ignore: unused_field
  final $Res Function(ProduceScreenEvent) _then;
}

/// @nodoc
abstract class _$PSEStartedCopyWith<$Res> {
  factory _$PSEStartedCopyWith(
          _PSEStarted value, $Res Function(_PSEStarted) then) =
      __$PSEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PSEStartedCopyWithImpl<$Res>
    extends _$ProduceScreenEventCopyWithImpl<$Res>
    implements _$PSEStartedCopyWith<$Res> {
  __$PSEStartedCopyWithImpl(
      _PSEStarted _value, $Res Function(_PSEStarted) _then)
      : super(_value, (v) => _then(v as _PSEStarted));

  @override
  _PSEStarted get _value => super._value as _PSEStarted;
}

/// @nodoc

class _$_PSEStarted implements _PSEStarted {
  const _$_PSEStarted();

  @override
  String toString() {
    return 'ProduceScreenEvent.started()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PSEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() tabChanged,
    required TResult Function() getAggregatePrices,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSEStarted value) started,
    required TResult Function(_PSETabChanged value) tabChanged,
    required TResult Function(_PSEGetAggregatePrices value) getAggregatePrices,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _PSEStarted implements ProduceScreenEvent {
  const factory _PSEStarted() = _$_PSEStarted;
}

/// @nodoc
abstract class _$PSETabChangedCopyWith<$Res> {
  factory _$PSETabChangedCopyWith(
          _PSETabChanged value, $Res Function(_PSETabChanged) then) =
      __$PSETabChangedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PSETabChangedCopyWithImpl<$Res>
    extends _$ProduceScreenEventCopyWithImpl<$Res>
    implements _$PSETabChangedCopyWith<$Res> {
  __$PSETabChangedCopyWithImpl(
      _PSETabChanged _value, $Res Function(_PSETabChanged) _then)
      : super(_value, (v) => _then(v as _PSETabChanged));

  @override
  _PSETabChanged get _value => super._value as _PSETabChanged;
}

/// @nodoc

class _$_PSETabChanged implements _PSETabChanged {
  const _$_PSETabChanged();

  @override
  String toString() {
    return 'ProduceScreenEvent.tabChanged()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PSETabChanged);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() tabChanged,
    required TResult Function() getAggregatePrices,
  }) {
    return tabChanged();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
  }) {
    return tabChanged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
    required TResult orElse(),
  }) {
    if (tabChanged != null) {
      return tabChanged();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSEStarted value) started,
    required TResult Function(_PSETabChanged value) tabChanged,
    required TResult Function(_PSEGetAggregatePrices value) getAggregatePrices,
  }) {
    return tabChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
  }) {
    return tabChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
    required TResult orElse(),
  }) {
    if (tabChanged != null) {
      return tabChanged(this);
    }
    return orElse();
  }
}

abstract class _PSETabChanged implements ProduceScreenEvent {
  const factory _PSETabChanged() = _$_PSETabChanged;
}

/// @nodoc
abstract class _$PSEGetAggregatePricesCopyWith<$Res> {
  factory _$PSEGetAggregatePricesCopyWith(_PSEGetAggregatePrices value,
          $Res Function(_PSEGetAggregatePrices) then) =
      __$PSEGetAggregatePricesCopyWithImpl<$Res>;
}

/// @nodoc
class __$PSEGetAggregatePricesCopyWithImpl<$Res>
    extends _$ProduceScreenEventCopyWithImpl<$Res>
    implements _$PSEGetAggregatePricesCopyWith<$Res> {
  __$PSEGetAggregatePricesCopyWithImpl(_PSEGetAggregatePrices _value,
      $Res Function(_PSEGetAggregatePrices) _then)
      : super(_value, (v) => _then(v as _PSEGetAggregatePrices));

  @override
  _PSEGetAggregatePrices get _value => super._value as _PSEGetAggregatePrices;
}

/// @nodoc

class _$_PSEGetAggregatePrices implements _PSEGetAggregatePrices {
  const _$_PSEGetAggregatePrices();

  @override
  String toString() {
    return 'ProduceScreenEvent.getAggregatePrices()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _PSEGetAggregatePrices);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() tabChanged,
    required TResult Function() getAggregatePrices,
  }) {
    return getAggregatePrices();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
  }) {
    return getAggregatePrices?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? tabChanged,
    TResult Function()? getAggregatePrices,
    required TResult orElse(),
  }) {
    if (getAggregatePrices != null) {
      return getAggregatePrices();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSEStarted value) started,
    required TResult Function(_PSETabChanged value) tabChanged,
    required TResult Function(_PSEGetAggregatePrices value) getAggregatePrices,
  }) {
    return getAggregatePrices(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
  }) {
    return getAggregatePrices?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSEStarted value)? started,
    TResult Function(_PSETabChanged value)? tabChanged,
    TResult Function(_PSEGetAggregatePrices value)? getAggregatePrices,
    required TResult orElse(),
  }) {
    if (getAggregatePrices != null) {
      return getAggregatePrices(this);
    }
    return orElse();
  }
}

abstract class _PSEGetAggregatePrices implements ProduceScreenEvent {
  const factory _PSEGetAggregatePrices() = _$_PSEGetAggregatePrices;
}

/// @nodoc
class _$ProduceScreenStateTearOff {
  const _$ProduceScreenStateTearOff();

  _PSSInitial initial({required ProduceScreenProps props}) {
    return _PSSInitial(
      props: props,
    );
  }

  _PSSLoading loading({required ProduceScreenProps props}) {
    return _PSSLoading(
      props: props,
    );
  }

  _PSSCompleted completed({required ProduceScreenProps props}) {
    return _PSSCompleted(
      props: props,
    );
  }
}

/// @nodoc
const $ProduceScreenState = _$ProduceScreenStateTearOff();

/// @nodoc
mixin _$ProduceScreenState {
  ProduceScreenProps get props => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ProduceScreenProps props) initial,
    required TResult Function(ProduceScreenProps props) loading,
    required TResult Function(ProduceScreenProps props) completed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSSInitial value) initial,
    required TResult Function(_PSSLoading value) loading,
    required TResult Function(_PSSCompleted value) completed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProduceScreenStateCopyWith<ProduceScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProduceScreenStateCopyWith<$Res> {
  factory $ProduceScreenStateCopyWith(
          ProduceScreenState value, $Res Function(ProduceScreenState) then) =
      _$ProduceScreenStateCopyWithImpl<$Res>;
  $Res call({ProduceScreenProps props});

  $ProduceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ProduceScreenStateCopyWithImpl<$Res>
    implements $ProduceScreenStateCopyWith<$Res> {
  _$ProduceScreenStateCopyWithImpl(this._value, this._then);

  final ProduceScreenState _value;
  // ignore: unused_field
  final $Res Function(ProduceScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as ProduceScreenProps,
    ));
  }

  @override
  $ProduceScreenPropsCopyWith<$Res> get props {
    return $ProduceScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class _$PSSInitialCopyWith<$Res>
    implements $ProduceScreenStateCopyWith<$Res> {
  factory _$PSSInitialCopyWith(
          _PSSInitial value, $Res Function(_PSSInitial) then) =
      __$PSSInitialCopyWithImpl<$Res>;
  @override
  $Res call({ProduceScreenProps props});

  @override
  $ProduceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$PSSInitialCopyWithImpl<$Res>
    extends _$ProduceScreenStateCopyWithImpl<$Res>
    implements _$PSSInitialCopyWith<$Res> {
  __$PSSInitialCopyWithImpl(
      _PSSInitial _value, $Res Function(_PSSInitial) _then)
      : super(_value, (v) => _then(v as _PSSInitial));

  @override
  _PSSInitial get _value => super._value as _PSSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_PSSInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as ProduceScreenProps,
    ));
  }
}

/// @nodoc

class _$_PSSInitial implements _PSSInitial {
  const _$_PSSInitial({required this.props});

  @override
  final ProduceScreenProps props;

  @override
  String toString() {
    return 'ProduceScreenState.initial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PSSInitial &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$PSSInitialCopyWith<_PSSInitial> get copyWith =>
      __$PSSInitialCopyWithImpl<_PSSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ProduceScreenProps props) initial,
    required TResult Function(ProduceScreenProps props) loading,
    required TResult Function(ProduceScreenProps props) completed,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSSInitial value) initial,
    required TResult Function(_PSSLoading value) loading,
    required TResult Function(_PSSCompleted value) completed,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _PSSInitial implements ProduceScreenState {
  const factory _PSSInitial({required ProduceScreenProps props}) =
      _$_PSSInitial;

  @override
  ProduceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$PSSInitialCopyWith<_PSSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PSSLoadingCopyWith<$Res>
    implements $ProduceScreenStateCopyWith<$Res> {
  factory _$PSSLoadingCopyWith(
          _PSSLoading value, $Res Function(_PSSLoading) then) =
      __$PSSLoadingCopyWithImpl<$Res>;
  @override
  $Res call({ProduceScreenProps props});

  @override
  $ProduceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$PSSLoadingCopyWithImpl<$Res>
    extends _$ProduceScreenStateCopyWithImpl<$Res>
    implements _$PSSLoadingCopyWith<$Res> {
  __$PSSLoadingCopyWithImpl(
      _PSSLoading _value, $Res Function(_PSSLoading) _then)
      : super(_value, (v) => _then(v as _PSSLoading));

  @override
  _PSSLoading get _value => super._value as _PSSLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_PSSLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as ProduceScreenProps,
    ));
  }
}

/// @nodoc

class _$_PSSLoading implements _PSSLoading {
  const _$_PSSLoading({required this.props});

  @override
  final ProduceScreenProps props;

  @override
  String toString() {
    return 'ProduceScreenState.loading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PSSLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$PSSLoadingCopyWith<_PSSLoading> get copyWith =>
      __$PSSLoadingCopyWithImpl<_PSSLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ProduceScreenProps props) initial,
    required TResult Function(ProduceScreenProps props) loading,
    required TResult Function(ProduceScreenProps props) completed,
  }) {
    return loading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
  }) {
    return loading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSSInitial value) initial,
    required TResult Function(_PSSLoading value) loading,
    required TResult Function(_PSSCompleted value) completed,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _PSSLoading implements ProduceScreenState {
  const factory _PSSLoading({required ProduceScreenProps props}) =
      _$_PSSLoading;

  @override
  ProduceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$PSSLoadingCopyWith<_PSSLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PSSCompletedCopyWith<$Res>
    implements $ProduceScreenStateCopyWith<$Res> {
  factory _$PSSCompletedCopyWith(
          _PSSCompleted value, $Res Function(_PSSCompleted) then) =
      __$PSSCompletedCopyWithImpl<$Res>;
  @override
  $Res call({ProduceScreenProps props});

  @override
  $ProduceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$PSSCompletedCopyWithImpl<$Res>
    extends _$ProduceScreenStateCopyWithImpl<$Res>
    implements _$PSSCompletedCopyWith<$Res> {
  __$PSSCompletedCopyWithImpl(
      _PSSCompleted _value, $Res Function(_PSSCompleted) _then)
      : super(_value, (v) => _then(v as _PSSCompleted));

  @override
  _PSSCompleted get _value => super._value as _PSSCompleted;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_PSSCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as ProduceScreenProps,
    ));
  }
}

/// @nodoc

class _$_PSSCompleted implements _PSSCompleted {
  const _$_PSSCompleted({required this.props});

  @override
  final ProduceScreenProps props;

  @override
  String toString() {
    return 'ProduceScreenState.completed(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _PSSCompleted &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$PSSCompletedCopyWith<_PSSCompleted> get copyWith =>
      __$PSSCompletedCopyWithImpl<_PSSCompleted>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ProduceScreenProps props) initial,
    required TResult Function(ProduceScreenProps props) loading,
    required TResult Function(ProduceScreenProps props) completed,
  }) {
    return completed(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
  }) {
    return completed?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ProduceScreenProps props)? initial,
    TResult Function(ProduceScreenProps props)? loading,
    TResult Function(ProduceScreenProps props)? completed,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PSSInitial value) initial,
    required TResult Function(_PSSLoading value) loading,
    required TResult Function(_PSSCompleted value) completed,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PSSInitial value)? initial,
    TResult Function(_PSSLoading value)? loading,
    TResult Function(_PSSCompleted value)? completed,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class _PSSCompleted implements ProduceScreenState {
  const factory _PSSCompleted({required ProduceScreenProps props}) =
      _$_PSSCompleted;

  @override
  ProduceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$PSSCompletedCopyWith<_PSSCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ProduceScreenPropsTearOff {
  const _$ProduceScreenPropsTearOff();

  _ProduceScreenProps call(
      {required TabController tabController,
      required int index,
      List<PriceSnippet>? twoWeeksPricesList,
      List<PriceSnippet>? oneMonthPricesList,
      List<PriceSnippet>? twoMonthPricesList,
      List<PriceSnippet>? sixMonthPricesList,
      List<PriceSnippet>? oneYearPricesList}) {
    return _ProduceScreenProps(
      tabController: tabController,
      index: index,
      twoWeeksPricesList: twoWeeksPricesList,
      oneMonthPricesList: oneMonthPricesList,
      twoMonthPricesList: twoMonthPricesList,
      sixMonthPricesList: sixMonthPricesList,
      oneYearPricesList: oneYearPricesList,
    );
  }
}

/// @nodoc
const $ProduceScreenProps = _$ProduceScreenPropsTearOff();

/// @nodoc
mixin _$ProduceScreenProps {
  TabController get tabController => throw _privateConstructorUsedError;
  int get index => throw _privateConstructorUsedError;
  List<PriceSnippet>? get twoWeeksPricesList =>
      throw _privateConstructorUsedError;
  List<PriceSnippet>? get oneMonthPricesList =>
      throw _privateConstructorUsedError;
  List<PriceSnippet>? get twoMonthPricesList =>
      throw _privateConstructorUsedError;
  List<PriceSnippet>? get sixMonthPricesList =>
      throw _privateConstructorUsedError;
  List<PriceSnippet>? get oneYearPricesList =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProduceScreenPropsCopyWith<ProduceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProduceScreenPropsCopyWith<$Res> {
  factory $ProduceScreenPropsCopyWith(
          ProduceScreenProps value, $Res Function(ProduceScreenProps) then) =
      _$ProduceScreenPropsCopyWithImpl<$Res>;
  $Res call(
      {TabController tabController,
      int index,
      List<PriceSnippet>? twoWeeksPricesList,
      List<PriceSnippet>? oneMonthPricesList,
      List<PriceSnippet>? twoMonthPricesList,
      List<PriceSnippet>? sixMonthPricesList,
      List<PriceSnippet>? oneYearPricesList});
}

/// @nodoc
class _$ProduceScreenPropsCopyWithImpl<$Res>
    implements $ProduceScreenPropsCopyWith<$Res> {
  _$ProduceScreenPropsCopyWithImpl(this._value, this._then);

  final ProduceScreenProps _value;
  // ignore: unused_field
  final $Res Function(ProduceScreenProps) _then;

  @override
  $Res call({
    Object? tabController = freezed,
    Object? index = freezed,
    Object? twoWeeksPricesList = freezed,
    Object? oneMonthPricesList = freezed,
    Object? twoMonthPricesList = freezed,
    Object? sixMonthPricesList = freezed,
    Object? oneYearPricesList = freezed,
  }) {
    return _then(_value.copyWith(
      tabController: tabController == freezed
          ? _value.tabController
          : tabController // ignore: cast_nullable_to_non_nullable
              as TabController,
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      twoWeeksPricesList: twoWeeksPricesList == freezed
          ? _value.twoWeeksPricesList
          : twoWeeksPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      oneMonthPricesList: oneMonthPricesList == freezed
          ? _value.oneMonthPricesList
          : oneMonthPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      twoMonthPricesList: twoMonthPricesList == freezed
          ? _value.twoMonthPricesList
          : twoMonthPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      sixMonthPricesList: sixMonthPricesList == freezed
          ? _value.sixMonthPricesList
          : sixMonthPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      oneYearPricesList: oneYearPricesList == freezed
          ? _value.oneYearPricesList
          : oneYearPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
    ));
  }
}

/// @nodoc
abstract class _$ProduceScreenPropsCopyWith<$Res>
    implements $ProduceScreenPropsCopyWith<$Res> {
  factory _$ProduceScreenPropsCopyWith(
          _ProduceScreenProps value, $Res Function(_ProduceScreenProps) then) =
      __$ProduceScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call(
      {TabController tabController,
      int index,
      List<PriceSnippet>? twoWeeksPricesList,
      List<PriceSnippet>? oneMonthPricesList,
      List<PriceSnippet>? twoMonthPricesList,
      List<PriceSnippet>? sixMonthPricesList,
      List<PriceSnippet>? oneYearPricesList});
}

/// @nodoc
class __$ProduceScreenPropsCopyWithImpl<$Res>
    extends _$ProduceScreenPropsCopyWithImpl<$Res>
    implements _$ProduceScreenPropsCopyWith<$Res> {
  __$ProduceScreenPropsCopyWithImpl(
      _ProduceScreenProps _value, $Res Function(_ProduceScreenProps) _then)
      : super(_value, (v) => _then(v as _ProduceScreenProps));

  @override
  _ProduceScreenProps get _value => super._value as _ProduceScreenProps;

  @override
  $Res call({
    Object? tabController = freezed,
    Object? index = freezed,
    Object? twoWeeksPricesList = freezed,
    Object? oneMonthPricesList = freezed,
    Object? twoMonthPricesList = freezed,
    Object? sixMonthPricesList = freezed,
    Object? oneYearPricesList = freezed,
  }) {
    return _then(_ProduceScreenProps(
      tabController: tabController == freezed
          ? _value.tabController
          : tabController // ignore: cast_nullable_to_non_nullable
              as TabController,
      index: index == freezed
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      twoWeeksPricesList: twoWeeksPricesList == freezed
          ? _value.twoWeeksPricesList
          : twoWeeksPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      oneMonthPricesList: oneMonthPricesList == freezed
          ? _value.oneMonthPricesList
          : oneMonthPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      twoMonthPricesList: twoMonthPricesList == freezed
          ? _value.twoMonthPricesList
          : twoMonthPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      sixMonthPricesList: sixMonthPricesList == freezed
          ? _value.sixMonthPricesList
          : sixMonthPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
      oneYearPricesList: oneYearPricesList == freezed
          ? _value.oneYearPricesList
          : oneYearPricesList // ignore: cast_nullable_to_non_nullable
              as List<PriceSnippet>?,
    ));
  }
}

/// @nodoc

class _$_ProduceScreenProps implements _ProduceScreenProps {
  const _$_ProduceScreenProps(
      {required this.tabController,
      required this.index,
      this.twoWeeksPricesList,
      this.oneMonthPricesList,
      this.twoMonthPricesList,
      this.sixMonthPricesList,
      this.oneYearPricesList});

  @override
  final TabController tabController;
  @override
  final int index;
  @override
  final List<PriceSnippet>? twoWeeksPricesList;
  @override
  final List<PriceSnippet>? oneMonthPricesList;
  @override
  final List<PriceSnippet>? twoMonthPricesList;
  @override
  final List<PriceSnippet>? sixMonthPricesList;
  @override
  final List<PriceSnippet>? oneYearPricesList;

  @override
  String toString() {
    return 'ProduceScreenProps(tabController: $tabController, index: $index, twoWeeksPricesList: $twoWeeksPricesList, oneMonthPricesList: $oneMonthPricesList, twoMonthPricesList: $twoMonthPricesList, sixMonthPricesList: $sixMonthPricesList, oneYearPricesList: $oneYearPricesList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ProduceScreenProps &&
            (identical(other.tabController, tabController) ||
                other.tabController == tabController) &&
            (identical(other.index, index) || other.index == index) &&
            const DeepCollectionEquality()
                .equals(other.twoWeeksPricesList, twoWeeksPricesList) &&
            const DeepCollectionEquality()
                .equals(other.oneMonthPricesList, oneMonthPricesList) &&
            const DeepCollectionEquality()
                .equals(other.twoMonthPricesList, twoMonthPricesList) &&
            const DeepCollectionEquality()
                .equals(other.sixMonthPricesList, sixMonthPricesList) &&
            const DeepCollectionEquality()
                .equals(other.oneYearPricesList, oneYearPricesList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      tabController,
      index,
      const DeepCollectionEquality().hash(twoWeeksPricesList),
      const DeepCollectionEquality().hash(oneMonthPricesList),
      const DeepCollectionEquality().hash(twoMonthPricesList),
      const DeepCollectionEquality().hash(sixMonthPricesList),
      const DeepCollectionEquality().hash(oneYearPricesList));

  @JsonKey(ignore: true)
  @override
  _$ProduceScreenPropsCopyWith<_ProduceScreenProps> get copyWith =>
      __$ProduceScreenPropsCopyWithImpl<_ProduceScreenProps>(this, _$identity);
}

abstract class _ProduceScreenProps implements ProduceScreenProps {
  const factory _ProduceScreenProps(
      {required TabController tabController,
      required int index,
      List<PriceSnippet>? twoWeeksPricesList,
      List<PriceSnippet>? oneMonthPricesList,
      List<PriceSnippet>? twoMonthPricesList,
      List<PriceSnippet>? sixMonthPricesList,
      List<PriceSnippet>? oneYearPricesList}) = _$_ProduceScreenProps;

  @override
  TabController get tabController;
  @override
  int get index;
  @override
  List<PriceSnippet>? get twoWeeksPricesList;
  @override
  List<PriceSnippet>? get oneMonthPricesList;
  @override
  List<PriceSnippet>? get twoMonthPricesList;
  @override
  List<PriceSnippet>? get sixMonthPricesList;
  @override
  List<PriceSnippet>? get oneYearPricesList;
  @override
  @JsonKey(ignore: true)
  _$ProduceScreenPropsCopyWith<_ProduceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'main_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MainScreenEventTearOff {
  const _$MainScreenEventTearOff();

  _MSEStarted started() {
    return const _MSEStarted();
  }

  _MSEGetFirstTenProduce getFirstTenProduce() {
    return const _MSEGetFirstTenProduce();
  }

  _MSEGetNextTenProduce getNextTenProduce() {
    return const _MSEGetNextTenProduce();
  }

  _MSEToggleMainHeader toggleMainHeader() {
    return const _MSEToggleMainHeader();
  }
}

/// @nodoc
const $MainScreenEvent = _$MainScreenEventTearOff();

/// @nodoc
mixin _$MainScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenEventCopyWith<$Res> {
  factory $MainScreenEventCopyWith(
          MainScreenEvent value, $Res Function(MainScreenEvent) then) =
      _$MainScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$MainScreenEventCopyWithImpl<$Res>
    implements $MainScreenEventCopyWith<$Res> {
  _$MainScreenEventCopyWithImpl(this._value, this._then);

  final MainScreenEvent _value;
  // ignore: unused_field
  final $Res Function(MainScreenEvent) _then;
}

/// @nodoc
abstract class _$MSEStartedCopyWith<$Res> {
  factory _$MSEStartedCopyWith(
          _MSEStarted value, $Res Function(_MSEStarted) then) =
      __$MSEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$MSEStartedCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$MSEStartedCopyWith<$Res> {
  __$MSEStartedCopyWithImpl(
      _MSEStarted _value, $Res Function(_MSEStarted) _then)
      : super(_value, (v) => _then(v as _MSEStarted));

  @override
  _MSEStarted get _value => super._value as _MSEStarted;
}

/// @nodoc

class _$_MSEStarted implements _MSEStarted {
  const _$_MSEStarted();

  @override
  String toString() {
    return 'MainScreenEvent.started()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _MSEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() toggleMainHeader,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _MSEStarted implements MainScreenEvent {
  const factory _MSEStarted() = _$_MSEStarted;
}

/// @nodoc
abstract class _$MSEGetFirstTenProduceCopyWith<$Res> {
  factory _$MSEGetFirstTenProduceCopyWith(_MSEGetFirstTenProduce value,
          $Res Function(_MSEGetFirstTenProduce) then) =
      __$MSEGetFirstTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$MSEGetFirstTenProduceCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$MSEGetFirstTenProduceCopyWith<$Res> {
  __$MSEGetFirstTenProduceCopyWithImpl(_MSEGetFirstTenProduce _value,
      $Res Function(_MSEGetFirstTenProduce) _then)
      : super(_value, (v) => _then(v as _MSEGetFirstTenProduce));

  @override
  _MSEGetFirstTenProduce get _value => super._value as _MSEGetFirstTenProduce;
}

/// @nodoc

class _$_MSEGetFirstTenProduce implements _MSEGetFirstTenProduce {
  const _$_MSEGetFirstTenProduce();

  @override
  String toString() {
    return 'MainScreenEvent.getFirstTenProduce()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _MSEGetFirstTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() toggleMainHeader,
  }) {
    return getFirstTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
  }) {
    return getFirstTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return getFirstTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return getFirstTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce(this);
    }
    return orElse();
  }
}

abstract class _MSEGetFirstTenProduce implements MainScreenEvent {
  const factory _MSEGetFirstTenProduce() = _$_MSEGetFirstTenProduce;
}

/// @nodoc
abstract class _$MSEGetNextTenProduceCopyWith<$Res> {
  factory _$MSEGetNextTenProduceCopyWith(_MSEGetNextTenProduce value,
          $Res Function(_MSEGetNextTenProduce) then) =
      __$MSEGetNextTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$MSEGetNextTenProduceCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$MSEGetNextTenProduceCopyWith<$Res> {
  __$MSEGetNextTenProduceCopyWithImpl(
      _MSEGetNextTenProduce _value, $Res Function(_MSEGetNextTenProduce) _then)
      : super(_value, (v) => _then(v as _MSEGetNextTenProduce));

  @override
  _MSEGetNextTenProduce get _value => super._value as _MSEGetNextTenProduce;
}

/// @nodoc

class _$_MSEGetNextTenProduce implements _MSEGetNextTenProduce {
  const _$_MSEGetNextTenProduce();

  @override
  String toString() {
    return 'MainScreenEvent.getNextTenProduce()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _MSEGetNextTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() toggleMainHeader,
  }) {
    return getNextTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
  }) {
    return getNextTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return getNextTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return getNextTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce(this);
    }
    return orElse();
  }
}

abstract class _MSEGetNextTenProduce implements MainScreenEvent {
  const factory _MSEGetNextTenProduce() = _$_MSEGetNextTenProduce;
}

/// @nodoc
abstract class _$MSEToggleMainHeaderCopyWith<$Res> {
  factory _$MSEToggleMainHeaderCopyWith(_MSEToggleMainHeader value,
          $Res Function(_MSEToggleMainHeader) then) =
      __$MSEToggleMainHeaderCopyWithImpl<$Res>;
}

/// @nodoc
class __$MSEToggleMainHeaderCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$MSEToggleMainHeaderCopyWith<$Res> {
  __$MSEToggleMainHeaderCopyWithImpl(
      _MSEToggleMainHeader _value, $Res Function(_MSEToggleMainHeader) _then)
      : super(_value, (v) => _then(v as _MSEToggleMainHeader));

  @override
  _MSEToggleMainHeader get _value => super._value as _MSEToggleMainHeader;
}

/// @nodoc

class _$_MSEToggleMainHeader implements _MSEToggleMainHeader {
  const _$_MSEToggleMainHeader();

  @override
  String toString() {
    return 'MainScreenEvent.toggleMainHeader()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _MSEToggleMainHeader);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() toggleMainHeader,
  }) {
    return toggleMainHeader();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
  }) {
    return toggleMainHeader?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (toggleMainHeader != null) {
      return toggleMainHeader();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return toggleMainHeader(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return toggleMainHeader?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (toggleMainHeader != null) {
      return toggleMainHeader(this);
    }
    return orElse();
  }
}

abstract class _MSEToggleMainHeader implements MainScreenEvent {
  const factory _MSEToggleMainHeader() = _$_MSEToggleMainHeader;
}

/// @nodoc
class _$MainScreenStateTearOff {
  const _$MainScreenStateTearOff();

  MSSInitial initial({required MainScreenProps props}) {
    return MSSInitial(
      props: props,
    );
  }

  MSSPricesLoading pricesLoading({required MainScreenProps props}) {
    return MSSPricesLoading(
      props: props,
    );
  }

  MSSNextPricesLoading nextPricesLoading({required MainScreenProps props}) {
    return MSSNextPricesLoading(
      props: props,
    );
  }

  MSSPricesCompleted pricesCompleted({required MainScreenProps props}) {
    return MSSPricesCompleted(
      props: props,
    );
  }

  MSSPricesError pricesError(
      {required MainScreenProps props,
      required String code,
      required String message}) {
    return MSSPricesError(
      props: props,
      code: code,
      message: message,
    );
  }
}

/// @nodoc
const $MainScreenState = _$MainScreenStateTearOff();

/// @nodoc
mixin _$MainScreenState {
  MainScreenProps get props => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MainScreenStateCopyWith<MainScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenStateCopyWith<$Res> {
  factory $MainScreenStateCopyWith(
          MainScreenState value, $Res Function(MainScreenState) then) =
      _$MainScreenStateCopyWithImpl<$Res>;
  $Res call({MainScreenProps props});

  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MainScreenStateCopyWithImpl<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  _$MainScreenStateCopyWithImpl(this._value, this._then);

  final MainScreenState _value;
  // ignore: unused_field
  final $Res Function(MainScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }

  @override
  $MainScreenPropsCopyWith<$Res> get props {
    return $MainScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class $MSSInitialCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSInitialCopyWith(
          MSSInitial value, $Res Function(MSSInitial) then) =
      _$MSSInitialCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSInitialCopyWithImpl<$Res> extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSInitialCopyWith<$Res> {
  _$MSSInitialCopyWithImpl(MSSInitial _value, $Res Function(MSSInitial) _then)
      : super(_value, (v) => _then(v as MSSInitial));

  @override
  MSSInitial get _value => super._value as MSSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSInitial implements MSSInitial {
  const _$MSSInitial({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.initial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSInitial &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSInitialCopyWith<MSSInitial> get copyWith =>
      _$MSSInitialCopyWithImpl<MSSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        pricesError,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class MSSInitial implements MainScreenState {
  const factory MSSInitial({required MainScreenProps props}) = _$MSSInitial;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSInitialCopyWith<MSSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSPricesLoadingCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSPricesLoadingCopyWith(
          MSSPricesLoading value, $Res Function(MSSPricesLoading) then) =
      _$MSSPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSPricesLoadingCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSPricesLoadingCopyWith<$Res> {
  _$MSSPricesLoadingCopyWithImpl(
      MSSPricesLoading _value, $Res Function(MSSPricesLoading) _then)
      : super(_value, (v) => _then(v as MSSPricesLoading));

  @override
  MSSPricesLoading get _value => super._value as MSSPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSPricesLoading implements MSSPricesLoading {
  const _$MSSPricesLoading({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.pricesLoading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSPricesLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSPricesLoadingCopyWith<MSSPricesLoading> get copyWith =>
      _$MSSPricesLoadingCopyWithImpl<MSSPricesLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        pricesError,
  }) {
    return pricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
  }) {
    return pricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return pricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return pricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(this);
    }
    return orElse();
  }
}

abstract class MSSPricesLoading implements MainScreenState {
  const factory MSSPricesLoading({required MainScreenProps props}) =
      _$MSSPricesLoading;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSPricesLoadingCopyWith<MSSPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSNextPricesLoadingCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSNextPricesLoadingCopyWith(MSSNextPricesLoading value,
          $Res Function(MSSNextPricesLoading) then) =
      _$MSSNextPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSNextPricesLoadingCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSNextPricesLoadingCopyWith<$Res> {
  _$MSSNextPricesLoadingCopyWithImpl(
      MSSNextPricesLoading _value, $Res Function(MSSNextPricesLoading) _then)
      : super(_value, (v) => _then(v as MSSNextPricesLoading));

  @override
  MSSNextPricesLoading get _value => super._value as MSSNextPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSNextPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSNextPricesLoading implements MSSNextPricesLoading {
  const _$MSSNextPricesLoading({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.nextPricesLoading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSNextPricesLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSNextPricesLoadingCopyWith<MSSNextPricesLoading> get copyWith =>
      _$MSSNextPricesLoadingCopyWithImpl<MSSNextPricesLoading>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        pricesError,
  }) {
    return nextPricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
  }) {
    return nextPricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return nextPricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return nextPricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(this);
    }
    return orElse();
  }
}

abstract class MSSNextPricesLoading implements MainScreenState {
  const factory MSSNextPricesLoading({required MainScreenProps props}) =
      _$MSSNextPricesLoading;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSNextPricesLoadingCopyWith<MSSNextPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSPricesCompletedCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSPricesCompletedCopyWith(
          MSSPricesCompleted value, $Res Function(MSSPricesCompleted) then) =
      _$MSSPricesCompletedCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSPricesCompletedCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSPricesCompletedCopyWith<$Res> {
  _$MSSPricesCompletedCopyWithImpl(
      MSSPricesCompleted _value, $Res Function(MSSPricesCompleted) _then)
      : super(_value, (v) => _then(v as MSSPricesCompleted));

  @override
  MSSPricesCompleted get _value => super._value as MSSPricesCompleted;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSPricesCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSPricesCompleted implements MSSPricesCompleted {
  const _$MSSPricesCompleted({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.pricesCompleted(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSPricesCompleted &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSPricesCompletedCopyWith<MSSPricesCompleted> get copyWith =>
      _$MSSPricesCompletedCopyWithImpl<MSSPricesCompleted>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        pricesError,
  }) {
    return pricesCompleted(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
  }) {
    return pricesCompleted?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return pricesCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return pricesCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(this);
    }
    return orElse();
  }
}

abstract class MSSPricesCompleted implements MainScreenState {
  const factory MSSPricesCompleted({required MainScreenProps props}) =
      _$MSSPricesCompleted;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSPricesCompletedCopyWith<MSSPricesCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSPricesErrorCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSPricesErrorCopyWith(
          MSSPricesError value, $Res Function(MSSPricesError) then) =
      _$MSSPricesErrorCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props, String code, String message});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSPricesErrorCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSPricesErrorCopyWith<$Res> {
  _$MSSPricesErrorCopyWithImpl(
      MSSPricesError _value, $Res Function(MSSPricesError) _then)
      : super(_value, (v) => _then(v as MSSPricesError));

  @override
  MSSPricesError get _value => super._value as MSSPricesError;

  @override
  $Res call({
    Object? props = freezed,
    Object? code = freezed,
    Object? message = freezed,
  }) {
    return _then(MSSPricesError(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$MSSPricesError implements MSSPricesError {
  const _$MSSPricesError(
      {required this.props, required this.code, required this.message});

  @override
  final MainScreenProps props;
  @override
  final String code;
  @override
  final String message;

  @override
  String toString() {
    return 'MainScreenState.pricesError(props: $props, code: $code, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSPricesError &&
            (identical(other.props, props) || other.props == props) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props, code, message);

  @JsonKey(ignore: true)
  @override
  $MSSPricesErrorCopyWith<MSSPricesError> get copyWith =>
      _$MSSPricesErrorCopyWithImpl<MSSPricesError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        pricesError,
  }) {
    return pricesError(props, code, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
  }) {
    return pricesError?.call(props, code, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        pricesError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(props, code, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return pricesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return pricesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(this);
    }
    return orElse();
  }
}

abstract class MSSPricesError implements MainScreenState {
  const factory MSSPricesError(
      {required MainScreenProps props,
      required String code,
      required String message}) = _$MSSPricesError;

  @override
  MainScreenProps get props;
  String get code;
  String get message;
  @override
  @JsonKey(ignore: true)
  $MSSPricesErrorCopyWith<MSSPricesError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$MainScreenPropsTearOff {
  const _$MainScreenPropsTearOff();

  _MainScreenProps call(
      {required bool isMainHeaderVisible, required List<Produce> produceList}) {
    return _MainScreenProps(
      isMainHeaderVisible: isMainHeaderVisible,
      produceList: produceList,
    );
  }
}

/// @nodoc
const $MainScreenProps = _$MainScreenPropsTearOff();

/// @nodoc
mixin _$MainScreenProps {
  bool get isMainHeaderVisible => throw _privateConstructorUsedError;
  List<Produce> get produceList => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MainScreenPropsCopyWith<MainScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenPropsCopyWith<$Res> {
  factory $MainScreenPropsCopyWith(
          MainScreenProps value, $Res Function(MainScreenProps) then) =
      _$MainScreenPropsCopyWithImpl<$Res>;
  $Res call({bool isMainHeaderVisible, List<Produce> produceList});
}

/// @nodoc
class _$MainScreenPropsCopyWithImpl<$Res>
    implements $MainScreenPropsCopyWith<$Res> {
  _$MainScreenPropsCopyWithImpl(this._value, this._then);

  final MainScreenProps _value;
  // ignore: unused_field
  final $Res Function(MainScreenProps) _then;

  @override
  $Res call({
    Object? isMainHeaderVisible = freezed,
    Object? produceList = freezed,
  }) {
    return _then(_value.copyWith(
      isMainHeaderVisible: isMainHeaderVisible == freezed
          ? _value.isMainHeaderVisible
          : isMainHeaderVisible // ignore: cast_nullable_to_non_nullable
              as bool,
      produceList: produceList == freezed
          ? _value.produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
    ));
  }
}

/// @nodoc
abstract class _$MainScreenPropsCopyWith<$Res>
    implements $MainScreenPropsCopyWith<$Res> {
  factory _$MainScreenPropsCopyWith(
          _MainScreenProps value, $Res Function(_MainScreenProps) then) =
      __$MainScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call({bool isMainHeaderVisible, List<Produce> produceList});
}

/// @nodoc
class __$MainScreenPropsCopyWithImpl<$Res>
    extends _$MainScreenPropsCopyWithImpl<$Res>
    implements _$MainScreenPropsCopyWith<$Res> {
  __$MainScreenPropsCopyWithImpl(
      _MainScreenProps _value, $Res Function(_MainScreenProps) _then)
      : super(_value, (v) => _then(v as _MainScreenProps));

  @override
  _MainScreenProps get _value => super._value as _MainScreenProps;

  @override
  $Res call({
    Object? isMainHeaderVisible = freezed,
    Object? produceList = freezed,
  }) {
    return _then(_MainScreenProps(
      isMainHeaderVisible: isMainHeaderVisible == freezed
          ? _value.isMainHeaderVisible
          : isMainHeaderVisible // ignore: cast_nullable_to_non_nullable
              as bool,
      produceList: produceList == freezed
          ? _value.produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
    ));
  }
}

/// @nodoc

class _$_MainScreenProps implements _MainScreenProps {
  const _$_MainScreenProps(
      {required this.isMainHeaderVisible, required this.produceList});

  @override
  final bool isMainHeaderVisible;
  @override
  final List<Produce> produceList;

  @override
  String toString() {
    return 'MainScreenProps(isMainHeaderVisible: $isMainHeaderVisible, produceList: $produceList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MainScreenProps &&
            (identical(other.isMainHeaderVisible, isMainHeaderVisible) ||
                other.isMainHeaderVisible == isMainHeaderVisible) &&
            const DeepCollectionEquality()
                .equals(other.produceList, produceList));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isMainHeaderVisible,
      const DeepCollectionEquality().hash(produceList));

  @JsonKey(ignore: true)
  @override
  _$MainScreenPropsCopyWith<_MainScreenProps> get copyWith =>
      __$MainScreenPropsCopyWithImpl<_MainScreenProps>(this, _$identity);
}

abstract class _MainScreenProps implements MainScreenProps {
  const factory _MainScreenProps(
      {required bool isMainHeaderVisible,
      required List<Produce> produceList}) = _$_MainScreenProps;

  @override
  bool get isMainHeaderVisible;
  @override
  List<Produce> get produceList;
  @override
  @JsonKey(ignore: true)
  _$MainScreenPropsCopyWith<_MainScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

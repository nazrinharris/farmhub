// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'main_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MainScreenEventTearOff {
  const _$MainScreenEventTearOff();

  _MSEStarted started() {
    return const _MSEStarted();
  }

  _MSEGetFirstTenProduce getFirstTenProduce() {
    return const _MSEGetFirstTenProduce();
  }

  _MSEToggleMainHeader toggleMainHeader() {
    return const _MSEToggleMainHeader();
  }
}

/// @nodoc
const $MainScreenEvent = _$MainScreenEventTearOff();

/// @nodoc
mixin _$MainScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenEventCopyWith<$Res> {
  factory $MainScreenEventCopyWith(
          MainScreenEvent value, $Res Function(MainScreenEvent) then) =
      _$MainScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$MainScreenEventCopyWithImpl<$Res>
    implements $MainScreenEventCopyWith<$Res> {
  _$MainScreenEventCopyWithImpl(this._value, this._then);

  final MainScreenEvent _value;
  // ignore: unused_field
  final $Res Function(MainScreenEvent) _then;
}

/// @nodoc
abstract class _$MSEStartedCopyWith<$Res> {
  factory _$MSEStartedCopyWith(
          _MSEStarted value, $Res Function(_MSEStarted) then) =
      __$MSEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$MSEStartedCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$MSEStartedCopyWith<$Res> {
  __$MSEStartedCopyWithImpl(
      _MSEStarted _value, $Res Function(_MSEStarted) _then)
      : super(_value, (v) => _then(v as _MSEStarted));

  @override
  _MSEStarted get _value => super._value as _MSEStarted;
}

/// @nodoc

class _$_MSEStarted implements _MSEStarted {
  const _$_MSEStarted();

  @override
  String toString() {
    return 'MainScreenEvent.started()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _MSEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() toggleMainHeader,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _MSEStarted implements MainScreenEvent {
  const factory _MSEStarted() = _$_MSEStarted;
}

/// @nodoc
abstract class _$MSEGetFirstTenProduceCopyWith<$Res> {
  factory _$MSEGetFirstTenProduceCopyWith(_MSEGetFirstTenProduce value,
          $Res Function(_MSEGetFirstTenProduce) then) =
      __$MSEGetFirstTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$MSEGetFirstTenProduceCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$MSEGetFirstTenProduceCopyWith<$Res> {
  __$MSEGetFirstTenProduceCopyWithImpl(_MSEGetFirstTenProduce _value,
      $Res Function(_MSEGetFirstTenProduce) _then)
      : super(_value, (v) => _then(v as _MSEGetFirstTenProduce));

  @override
  _MSEGetFirstTenProduce get _value => super._value as _MSEGetFirstTenProduce;
}

/// @nodoc

class _$_MSEGetFirstTenProduce implements _MSEGetFirstTenProduce {
  const _$_MSEGetFirstTenProduce();

  @override
  String toString() {
    return 'MainScreenEvent.getFirstTenProduce()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _MSEGetFirstTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() toggleMainHeader,
  }) {
    return getFirstTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
  }) {
    return getFirstTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return getFirstTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return getFirstTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce(this);
    }
    return orElse();
  }
}

abstract class _MSEGetFirstTenProduce implements MainScreenEvent {
  const factory _MSEGetFirstTenProduce() = _$_MSEGetFirstTenProduce;
}

/// @nodoc
abstract class _$MSEToggleMainHeaderCopyWith<$Res> {
  factory _$MSEToggleMainHeaderCopyWith(_MSEToggleMainHeader value,
          $Res Function(_MSEToggleMainHeader) then) =
      __$MSEToggleMainHeaderCopyWithImpl<$Res>;
}

/// @nodoc
class __$MSEToggleMainHeaderCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$MSEToggleMainHeaderCopyWith<$Res> {
  __$MSEToggleMainHeaderCopyWithImpl(
      _MSEToggleMainHeader _value, $Res Function(_MSEToggleMainHeader) _then)
      : super(_value, (v) => _then(v as _MSEToggleMainHeader));

  @override
  _MSEToggleMainHeader get _value => super._value as _MSEToggleMainHeader;
}

/// @nodoc

class _$_MSEToggleMainHeader implements _MSEToggleMainHeader {
  const _$_MSEToggleMainHeader();

  @override
  String toString() {
    return 'MainScreenEvent.toggleMainHeader()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _MSEToggleMainHeader);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() toggleMainHeader,
  }) {
    return toggleMainHeader();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
  }) {
    return toggleMainHeader?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (toggleMainHeader != null) {
      return toggleMainHeader();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return toggleMainHeader(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return toggleMainHeader?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (toggleMainHeader != null) {
      return toggleMainHeader(this);
    }
    return orElse();
  }
}

abstract class _MSEToggleMainHeader implements MainScreenEvent {
  const factory _MSEToggleMainHeader() = _$_MSEToggleMainHeader;
}

/// @nodoc
class _$MainScreenStateTearOff {
  const _$MainScreenStateTearOff();

  MSSInitial initial({required MainScreenProps props}) {
    return MSSInitial(
      props: props,
    );
  }

  MSSPricesLoading mainPricesLoading({required MainScreenProps props}) {
    return MSSPricesLoading(
      props: props,
    );
  }

  MSSPricesCompleted mainPricesCompleted(
      {required MainScreenProps props, required List<Produce> produceList}) {
    return MSSPricesCompleted(
      props: props,
      produceList: produceList,
    );
  }

  MSSPricesError mainPricesError(
      {required MainScreenProps props,
      required String code,
      required String message}) {
    return MSSPricesError(
      props: props,
      code: code,
      message: message,
    );
  }

  MSSSearchInitial searchInitial({required MainScreenProps props}) {
    return MSSSearchInitial(
      props: props,
    );
  }

  MSSSearchLoading searchLoading({required MainScreenProps props}) {
    return MSSSearchLoading(
      props: props,
    );
  }

  MSSSearchCompleted searchCompleted({required MainScreenProps props}) {
    return MSSSearchCompleted(
      props: props,
    );
  }

  MSSSearchError searchError({required MainScreenProps props}) {
    return MSSSearchError(
      props: props,
    );
  }
}

/// @nodoc
const $MainScreenState = _$MainScreenStateTearOff();

/// @nodoc
mixin _$MainScreenState {
  MainScreenProps get props => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MainScreenStateCopyWith<MainScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenStateCopyWith<$Res> {
  factory $MainScreenStateCopyWith(
          MainScreenState value, $Res Function(MainScreenState) then) =
      _$MainScreenStateCopyWithImpl<$Res>;
  $Res call({MainScreenProps props});

  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MainScreenStateCopyWithImpl<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  _$MainScreenStateCopyWithImpl(this._value, this._then);

  final MainScreenState _value;
  // ignore: unused_field
  final $Res Function(MainScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }

  @override
  $MainScreenPropsCopyWith<$Res> get props {
    return $MainScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class $MSSInitialCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSInitialCopyWith(
          MSSInitial value, $Res Function(MSSInitial) then) =
      _$MSSInitialCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSInitialCopyWithImpl<$Res> extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSInitialCopyWith<$Res> {
  _$MSSInitialCopyWithImpl(MSSInitial _value, $Res Function(MSSInitial) _then)
      : super(_value, (v) => _then(v as MSSInitial));

  @override
  MSSInitial get _value => super._value as MSSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSInitial implements MSSInitial {
  const _$MSSInitial({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.initial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSInitial &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSInitialCopyWith<MSSInitial> get copyWith =>
      _$MSSInitialCopyWithImpl<MSSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class MSSInitial implements MainScreenState {
  const factory MSSInitial({required MainScreenProps props}) = _$MSSInitial;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSInitialCopyWith<MSSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSPricesLoadingCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSPricesLoadingCopyWith(
          MSSPricesLoading value, $Res Function(MSSPricesLoading) then) =
      _$MSSPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSPricesLoadingCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSPricesLoadingCopyWith<$Res> {
  _$MSSPricesLoadingCopyWithImpl(
      MSSPricesLoading _value, $Res Function(MSSPricesLoading) _then)
      : super(_value, (v) => _then(v as MSSPricesLoading));

  @override
  MSSPricesLoading get _value => super._value as MSSPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSPricesLoading implements MSSPricesLoading {
  const _$MSSPricesLoading({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.mainPricesLoading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSPricesLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSPricesLoadingCopyWith<MSSPricesLoading> get copyWith =>
      _$MSSPricesLoadingCopyWithImpl<MSSPricesLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return mainPricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return mainPricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (mainPricesLoading != null) {
      return mainPricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return mainPricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return mainPricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (mainPricesLoading != null) {
      return mainPricesLoading(this);
    }
    return orElse();
  }
}

abstract class MSSPricesLoading implements MainScreenState {
  const factory MSSPricesLoading({required MainScreenProps props}) =
      _$MSSPricesLoading;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSPricesLoadingCopyWith<MSSPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSPricesCompletedCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSPricesCompletedCopyWith(
          MSSPricesCompleted value, $Res Function(MSSPricesCompleted) then) =
      _$MSSPricesCompletedCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props, List<Produce> produceList});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSPricesCompletedCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSPricesCompletedCopyWith<$Res> {
  _$MSSPricesCompletedCopyWithImpl(
      MSSPricesCompleted _value, $Res Function(MSSPricesCompleted) _then)
      : super(_value, (v) => _then(v as MSSPricesCompleted));

  @override
  MSSPricesCompleted get _value => super._value as MSSPricesCompleted;

  @override
  $Res call({
    Object? props = freezed,
    Object? produceList = freezed,
  }) {
    return _then(MSSPricesCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
      produceList: produceList == freezed
          ? _value.produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
    ));
  }
}

/// @nodoc

class _$MSSPricesCompleted implements MSSPricesCompleted {
  const _$MSSPricesCompleted({required this.props, required this.produceList});

  @override
  final MainScreenProps props;
  @override
  final List<Produce> produceList;

  @override
  String toString() {
    return 'MainScreenState.mainPricesCompleted(props: $props, produceList: $produceList)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSPricesCompleted &&
            (identical(other.props, props) || other.props == props) &&
            const DeepCollectionEquality()
                .equals(other.produceList, produceList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, props, const DeepCollectionEquality().hash(produceList));

  @JsonKey(ignore: true)
  @override
  $MSSPricesCompletedCopyWith<MSSPricesCompleted> get copyWith =>
      _$MSSPricesCompletedCopyWithImpl<MSSPricesCompleted>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return mainPricesCompleted(props, produceList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return mainPricesCompleted?.call(props, produceList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (mainPricesCompleted != null) {
      return mainPricesCompleted(props, produceList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return mainPricesCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return mainPricesCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (mainPricesCompleted != null) {
      return mainPricesCompleted(this);
    }
    return orElse();
  }
}

abstract class MSSPricesCompleted implements MainScreenState {
  const factory MSSPricesCompleted(
      {required MainScreenProps props,
      required List<Produce> produceList}) = _$MSSPricesCompleted;

  @override
  MainScreenProps get props;
  List<Produce> get produceList;
  @override
  @JsonKey(ignore: true)
  $MSSPricesCompletedCopyWith<MSSPricesCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSPricesErrorCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSPricesErrorCopyWith(
          MSSPricesError value, $Res Function(MSSPricesError) then) =
      _$MSSPricesErrorCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props, String code, String message});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSPricesErrorCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSPricesErrorCopyWith<$Res> {
  _$MSSPricesErrorCopyWithImpl(
      MSSPricesError _value, $Res Function(MSSPricesError) _then)
      : super(_value, (v) => _then(v as MSSPricesError));

  @override
  MSSPricesError get _value => super._value as MSSPricesError;

  @override
  $Res call({
    Object? props = freezed,
    Object? code = freezed,
    Object? message = freezed,
  }) {
    return _then(MSSPricesError(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      message: message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$MSSPricesError implements MSSPricesError {
  const _$MSSPricesError(
      {required this.props, required this.code, required this.message});

  @override
  final MainScreenProps props;
  @override
  final String code;
  @override
  final String message;

  @override
  String toString() {
    return 'MainScreenState.mainPricesError(props: $props, code: $code, message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSPricesError &&
            (identical(other.props, props) || other.props == props) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props, code, message);

  @JsonKey(ignore: true)
  @override
  $MSSPricesErrorCopyWith<MSSPricesError> get copyWith =>
      _$MSSPricesErrorCopyWithImpl<MSSPricesError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return mainPricesError(props, code, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return mainPricesError?.call(props, code, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (mainPricesError != null) {
      return mainPricesError(props, code, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return mainPricesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return mainPricesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (mainPricesError != null) {
      return mainPricesError(this);
    }
    return orElse();
  }
}

abstract class MSSPricesError implements MainScreenState {
  const factory MSSPricesError(
      {required MainScreenProps props,
      required String code,
      required String message}) = _$MSSPricesError;

  @override
  MainScreenProps get props;
  String get code;
  String get message;
  @override
  @JsonKey(ignore: true)
  $MSSPricesErrorCopyWith<MSSPricesError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSSearchInitialCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSSearchInitialCopyWith(
          MSSSearchInitial value, $Res Function(MSSSearchInitial) then) =
      _$MSSSearchInitialCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSSearchInitialCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSSearchInitialCopyWith<$Res> {
  _$MSSSearchInitialCopyWithImpl(
      MSSSearchInitial _value, $Res Function(MSSSearchInitial) _then)
      : super(_value, (v) => _then(v as MSSSearchInitial));

  @override
  MSSSearchInitial get _value => super._value as MSSSearchInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSSearchInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSSearchInitial implements MSSSearchInitial {
  const _$MSSSearchInitial({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.searchInitial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSSearchInitial &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSSearchInitialCopyWith<MSSSearchInitial> get copyWith =>
      _$MSSSearchInitialCopyWithImpl<MSSSearchInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return searchInitial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return searchInitial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (searchInitial != null) {
      return searchInitial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return searchInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return searchInitial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (searchInitial != null) {
      return searchInitial(this);
    }
    return orElse();
  }
}

abstract class MSSSearchInitial implements MainScreenState {
  const factory MSSSearchInitial({required MainScreenProps props}) =
      _$MSSSearchInitial;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSSearchInitialCopyWith<MSSSearchInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSSearchLoadingCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSSearchLoadingCopyWith(
          MSSSearchLoading value, $Res Function(MSSSearchLoading) then) =
      _$MSSSearchLoadingCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSSearchLoadingCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSSearchLoadingCopyWith<$Res> {
  _$MSSSearchLoadingCopyWithImpl(
      MSSSearchLoading _value, $Res Function(MSSSearchLoading) _then)
      : super(_value, (v) => _then(v as MSSSearchLoading));

  @override
  MSSSearchLoading get _value => super._value as MSSSearchLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSSearchLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSSearchLoading implements MSSSearchLoading {
  const _$MSSSearchLoading({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.searchLoading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSSearchLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSSearchLoadingCopyWith<MSSSearchLoading> get copyWith =>
      _$MSSSearchLoadingCopyWithImpl<MSSSearchLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return searchLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return searchLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (searchLoading != null) {
      return searchLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return searchLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return searchLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (searchLoading != null) {
      return searchLoading(this);
    }
    return orElse();
  }
}

abstract class MSSSearchLoading implements MainScreenState {
  const factory MSSSearchLoading({required MainScreenProps props}) =
      _$MSSSearchLoading;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSSearchLoadingCopyWith<MSSSearchLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSSearchCompletedCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSSearchCompletedCopyWith(
          MSSSearchCompleted value, $Res Function(MSSSearchCompleted) then) =
      _$MSSSearchCompletedCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSSearchCompletedCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSSearchCompletedCopyWith<$Res> {
  _$MSSSearchCompletedCopyWithImpl(
      MSSSearchCompleted _value, $Res Function(MSSSearchCompleted) _then)
      : super(_value, (v) => _then(v as MSSSearchCompleted));

  @override
  MSSSearchCompleted get _value => super._value as MSSSearchCompleted;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSSearchCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSSearchCompleted implements MSSSearchCompleted {
  const _$MSSSearchCompleted({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.searchCompleted(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSSearchCompleted &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSSearchCompletedCopyWith<MSSSearchCompleted> get copyWith =>
      _$MSSSearchCompletedCopyWithImpl<MSSSearchCompleted>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return searchCompleted(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return searchCompleted?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (searchCompleted != null) {
      return searchCompleted(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return searchCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return searchCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (searchCompleted != null) {
      return searchCompleted(this);
    }
    return orElse();
  }
}

abstract class MSSSearchCompleted implements MainScreenState {
  const factory MSSSearchCompleted({required MainScreenProps props}) =
      _$MSSSearchCompleted;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSSearchCompletedCopyWith<MSSSearchCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MSSSearchErrorCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory $MSSSearchErrorCopyWith(
          MSSSearchError value, $Res Function(MSSSearchError) then) =
      _$MSSSearchErrorCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MSSSearchErrorCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements $MSSSearchErrorCopyWith<$Res> {
  _$MSSSearchErrorCopyWithImpl(
      MSSSearchError _value, $Res Function(MSSSearchError) _then)
      : super(_value, (v) => _then(v as MSSSearchError));

  @override
  MSSSearchError get _value => super._value as MSSSearchError;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(MSSSearchError(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSSearchError implements MSSSearchError {
  const _$MSSSearchError({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.searchError(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MSSSearchError &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $MSSSearchErrorCopyWith<MSSSearchError> get copyWith =>
      _$MSSSearchErrorCopyWithImpl<MSSSearchError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) mainPricesLoading,
    required TResult Function(MainScreenProps props, List<Produce> produceList)
        mainPricesCompleted,
    required TResult Function(
            MainScreenProps props, String code, String message)
        mainPricesError,
    required TResult Function(MainScreenProps props) searchInitial,
    required TResult Function(MainScreenProps props) searchLoading,
    required TResult Function(MainScreenProps props) searchCompleted,
    required TResult Function(MainScreenProps props) searchError,
  }) {
    return searchError(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
  }) {
    return searchError?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? mainPricesLoading,
    TResult Function(MainScreenProps props, List<Produce> produceList)?
        mainPricesCompleted,
    TResult Function(MainScreenProps props, String code, String message)?
        mainPricesError,
    TResult Function(MainScreenProps props)? searchInitial,
    TResult Function(MainScreenProps props)? searchLoading,
    TResult Function(MainScreenProps props)? searchCompleted,
    TResult Function(MainScreenProps props)? searchError,
    required TResult orElse(),
  }) {
    if (searchError != null) {
      return searchError(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) mainPricesLoading,
    required TResult Function(MSSPricesCompleted value) mainPricesCompleted,
    required TResult Function(MSSPricesError value) mainPricesError,
    required TResult Function(MSSSearchInitial value) searchInitial,
    required TResult Function(MSSSearchLoading value) searchLoading,
    required TResult Function(MSSSearchCompleted value) searchCompleted,
    required TResult Function(MSSSearchError value) searchError,
  }) {
    return searchError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
  }) {
    return searchError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? mainPricesLoading,
    TResult Function(MSSPricesCompleted value)? mainPricesCompleted,
    TResult Function(MSSPricesError value)? mainPricesError,
    TResult Function(MSSSearchInitial value)? searchInitial,
    TResult Function(MSSSearchLoading value)? searchLoading,
    TResult Function(MSSSearchCompleted value)? searchCompleted,
    TResult Function(MSSSearchError value)? searchError,
    required TResult orElse(),
  }) {
    if (searchError != null) {
      return searchError(this);
    }
    return orElse();
  }
}

abstract class MSSSearchError implements MainScreenState {
  const factory MSSSearchError({required MainScreenProps props}) =
      _$MSSSearchError;

  @override
  MainScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $MSSSearchErrorCopyWith<MSSSearchError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$MainScreenPropsTearOff {
  const _$MainScreenPropsTearOff();

  _MainScreenProps call({required bool isMainHeaderVisible}) {
    return _MainScreenProps(
      isMainHeaderVisible: isMainHeaderVisible,
    );
  }
}

/// @nodoc
const $MainScreenProps = _$MainScreenPropsTearOff();

/// @nodoc
mixin _$MainScreenProps {
  bool get isMainHeaderVisible => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MainScreenPropsCopyWith<MainScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenPropsCopyWith<$Res> {
  factory $MainScreenPropsCopyWith(
          MainScreenProps value, $Res Function(MainScreenProps) then) =
      _$MainScreenPropsCopyWithImpl<$Res>;
  $Res call({bool isMainHeaderVisible});
}

/// @nodoc
class _$MainScreenPropsCopyWithImpl<$Res>
    implements $MainScreenPropsCopyWith<$Res> {
  _$MainScreenPropsCopyWithImpl(this._value, this._then);

  final MainScreenProps _value;
  // ignore: unused_field
  final $Res Function(MainScreenProps) _then;

  @override
  $Res call({
    Object? isMainHeaderVisible = freezed,
  }) {
    return _then(_value.copyWith(
      isMainHeaderVisible: isMainHeaderVisible == freezed
          ? _value.isMainHeaderVisible
          : isMainHeaderVisible // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$MainScreenPropsCopyWith<$Res>
    implements $MainScreenPropsCopyWith<$Res> {
  factory _$MainScreenPropsCopyWith(
          _MainScreenProps value, $Res Function(_MainScreenProps) then) =
      __$MainScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call({bool isMainHeaderVisible});
}

/// @nodoc
class __$MainScreenPropsCopyWithImpl<$Res>
    extends _$MainScreenPropsCopyWithImpl<$Res>
    implements _$MainScreenPropsCopyWith<$Res> {
  __$MainScreenPropsCopyWithImpl(
      _MainScreenProps _value, $Res Function(_MainScreenProps) _then)
      : super(_value, (v) => _then(v as _MainScreenProps));

  @override
  _MainScreenProps get _value => super._value as _MainScreenProps;

  @override
  $Res call({
    Object? isMainHeaderVisible = freezed,
  }) {
    return _then(_MainScreenProps(
      isMainHeaderVisible: isMainHeaderVisible == freezed
          ? _value.isMainHeaderVisible
          : isMainHeaderVisible // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_MainScreenProps implements _MainScreenProps {
  const _$_MainScreenProps({required this.isMainHeaderVisible});

  @override
  final bool isMainHeaderVisible;

  @override
  String toString() {
    return 'MainScreenProps(isMainHeaderVisible: $isMainHeaderVisible)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MainScreenProps &&
            (identical(other.isMainHeaderVisible, isMainHeaderVisible) ||
                other.isMainHeaderVisible == isMainHeaderVisible));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isMainHeaderVisible);

  @JsonKey(ignore: true)
  @override
  _$MainScreenPropsCopyWith<_MainScreenProps> get copyWith =>
      __$MainScreenPropsCopyWithImpl<_MainScreenProps>(this, _$identity);
}

abstract class _MainScreenProps implements MainScreenProps {
  const factory _MainScreenProps({required bool isMainHeaderVisible}) =
      _$_MainScreenProps;

  @override
  bool get isMainHeaderVisible;
  @override
  @JsonKey(ignore: true)
  _$MainScreenPropsCopyWith<_MainScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

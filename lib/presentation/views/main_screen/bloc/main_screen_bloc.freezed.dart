// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'main_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MainScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() refresh,
    required TResult Function() toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSERefresh value) refresh,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenEventCopyWith<$Res> {
  factory $MainScreenEventCopyWith(
          MainScreenEvent value, $Res Function(MainScreenEvent) then) =
      _$MainScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$MainScreenEventCopyWithImpl<$Res>
    implements $MainScreenEventCopyWith<$Res> {
  _$MainScreenEventCopyWithImpl(this._value, this._then);

  final MainScreenEvent _value;
  // ignore: unused_field
  final $Res Function(MainScreenEvent) _then;
}

/// @nodoc
abstract class _$$_MSEStartedCopyWith<$Res> {
  factory _$$_MSEStartedCopyWith(
          _$_MSEStarted value, $Res Function(_$_MSEStarted) then) =
      __$$_MSEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MSEStartedCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$$_MSEStartedCopyWith<$Res> {
  __$$_MSEStartedCopyWithImpl(
      _$_MSEStarted _value, $Res Function(_$_MSEStarted) _then)
      : super(_value, (v) => _then(v as _$_MSEStarted));

  @override
  _$_MSEStarted get _value => super._value as _$_MSEStarted;
}

/// @nodoc

class _$_MSEStarted implements _MSEStarted {
  const _$_MSEStarted();

  @override
  String toString() {
    return 'MainScreenEvent.started()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MSEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() refresh,
    required TResult Function() toggleMainHeader,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSERefresh value) refresh,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _MSEStarted implements MainScreenEvent {
  const factory _MSEStarted() = _$_MSEStarted;
}

/// @nodoc
abstract class _$$_MSEGetFirstTenProduceCopyWith<$Res> {
  factory _$$_MSEGetFirstTenProduceCopyWith(_$_MSEGetFirstTenProduce value,
          $Res Function(_$_MSEGetFirstTenProduce) then) =
      __$$_MSEGetFirstTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MSEGetFirstTenProduceCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$$_MSEGetFirstTenProduceCopyWith<$Res> {
  __$$_MSEGetFirstTenProduceCopyWithImpl(_$_MSEGetFirstTenProduce _value,
      $Res Function(_$_MSEGetFirstTenProduce) _then)
      : super(_value, (v) => _then(v as _$_MSEGetFirstTenProduce));

  @override
  _$_MSEGetFirstTenProduce get _value =>
      super._value as _$_MSEGetFirstTenProduce;
}

/// @nodoc

class _$_MSEGetFirstTenProduce implements _MSEGetFirstTenProduce {
  const _$_MSEGetFirstTenProduce();

  @override
  String toString() {
    return 'MainScreenEvent.getFirstTenProduce()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MSEGetFirstTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() refresh,
    required TResult Function() toggleMainHeader,
  }) {
    return getFirstTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
  }) {
    return getFirstTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSERefresh value) refresh,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return getFirstTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return getFirstTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce(this);
    }
    return orElse();
  }
}

abstract class _MSEGetFirstTenProduce implements MainScreenEvent {
  const factory _MSEGetFirstTenProduce() = _$_MSEGetFirstTenProduce;
}

/// @nodoc
abstract class _$$_MSEGetNextTenProduceCopyWith<$Res> {
  factory _$$_MSEGetNextTenProduceCopyWith(_$_MSEGetNextTenProduce value,
          $Res Function(_$_MSEGetNextTenProduce) then) =
      __$$_MSEGetNextTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MSEGetNextTenProduceCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$$_MSEGetNextTenProduceCopyWith<$Res> {
  __$$_MSEGetNextTenProduceCopyWithImpl(_$_MSEGetNextTenProduce _value,
      $Res Function(_$_MSEGetNextTenProduce) _then)
      : super(_value, (v) => _then(v as _$_MSEGetNextTenProduce));

  @override
  _$_MSEGetNextTenProduce get _value => super._value as _$_MSEGetNextTenProduce;
}

/// @nodoc

class _$_MSEGetNextTenProduce implements _MSEGetNextTenProduce {
  const _$_MSEGetNextTenProduce();

  @override
  String toString() {
    return 'MainScreenEvent.getNextTenProduce()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MSEGetNextTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() refresh,
    required TResult Function() toggleMainHeader,
  }) {
    return getNextTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
  }) {
    return getNextTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSERefresh value) refresh,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return getNextTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return getNextTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce(this);
    }
    return orElse();
  }
}

abstract class _MSEGetNextTenProduce implements MainScreenEvent {
  const factory _MSEGetNextTenProduce() = _$_MSEGetNextTenProduce;
}

/// @nodoc
abstract class _$$_MSERefreshCopyWith<$Res> {
  factory _$$_MSERefreshCopyWith(
          _$_MSERefresh value, $Res Function(_$_MSERefresh) then) =
      __$$_MSERefreshCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MSERefreshCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$$_MSERefreshCopyWith<$Res> {
  __$$_MSERefreshCopyWithImpl(
      _$_MSERefresh _value, $Res Function(_$_MSERefresh) _then)
      : super(_value, (v) => _then(v as _$_MSERefresh));

  @override
  _$_MSERefresh get _value => super._value as _$_MSERefresh;
}

/// @nodoc

class _$_MSERefresh implements _MSERefresh {
  const _$_MSERefresh();

  @override
  String toString() {
    return 'MainScreenEvent.refresh()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MSERefresh);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() refresh,
    required TResult Function() toggleMainHeader,
  }) {
    return refresh();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
  }) {
    return refresh?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSERefresh value) refresh,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return refresh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return refresh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh(this);
    }
    return orElse();
  }
}

abstract class _MSERefresh implements MainScreenEvent {
  const factory _MSERefresh() = _$_MSERefresh;
}

/// @nodoc
abstract class _$$_MSEToggleMainHeaderCopyWith<$Res> {
  factory _$$_MSEToggleMainHeaderCopyWith(_$_MSEToggleMainHeader value,
          $Res Function(_$_MSEToggleMainHeader) then) =
      __$$_MSEToggleMainHeaderCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MSEToggleMainHeaderCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res>
    implements _$$_MSEToggleMainHeaderCopyWith<$Res> {
  __$$_MSEToggleMainHeaderCopyWithImpl(_$_MSEToggleMainHeader _value,
      $Res Function(_$_MSEToggleMainHeader) _then)
      : super(_value, (v) => _then(v as _$_MSEToggleMainHeader));

  @override
  _$_MSEToggleMainHeader get _value => super._value as _$_MSEToggleMainHeader;
}

/// @nodoc

class _$_MSEToggleMainHeader implements _MSEToggleMainHeader {
  const _$_MSEToggleMainHeader();

  @override
  String toString() {
    return 'MainScreenEvent.toggleMainHeader()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_MSEToggleMainHeader);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function() refresh,
    required TResult Function() toggleMainHeader,
  }) {
    return toggleMainHeader();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
  }) {
    return toggleMainHeader?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function()? refresh,
    TResult Function()? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (toggleMainHeader != null) {
      return toggleMainHeader();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MSEStarted value) started,
    required TResult Function(_MSEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_MSEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_MSERefresh value) refresh,
    required TResult Function(_MSEToggleMainHeader value) toggleMainHeader,
  }) {
    return toggleMainHeader(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
  }) {
    return toggleMainHeader?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MSEStarted value)? started,
    TResult Function(_MSEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_MSEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_MSERefresh value)? refresh,
    TResult Function(_MSEToggleMainHeader value)? toggleMainHeader,
    required TResult orElse(),
  }) {
    if (toggleMainHeader != null) {
      return toggleMainHeader(this);
    }
    return orElse();
  }
}

abstract class _MSEToggleMainHeader implements MainScreenEvent {
  const factory _MSEToggleMainHeader() = _$_MSEToggleMainHeader;
}

/// @nodoc
mixin _$MainScreenState {
  MainScreenProps get props => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(MainScreenProps props, Failure failure)
        pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MainScreenStateCopyWith<MainScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenStateCopyWith<$Res> {
  factory $MainScreenStateCopyWith(
          MainScreenState value, $Res Function(MainScreenState) then) =
      _$MainScreenStateCopyWithImpl<$Res>;
  $Res call({MainScreenProps props});

  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$MainScreenStateCopyWithImpl<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  _$MainScreenStateCopyWithImpl(this._value, this._then);

  final MainScreenState _value;
  // ignore: unused_field
  final $Res Function(MainScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }

  @override
  $MainScreenPropsCopyWith<$Res> get props {
    return $MainScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class _$$MSSInitialCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory _$$MSSInitialCopyWith(
          _$MSSInitial value, $Res Function(_$MSSInitial) then) =
      __$$MSSInitialCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$MSSInitialCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements _$$MSSInitialCopyWith<$Res> {
  __$$MSSInitialCopyWithImpl(
      _$MSSInitial _value, $Res Function(_$MSSInitial) _then)
      : super(_value, (v) => _then(v as _$MSSInitial));

  @override
  _$MSSInitial get _value => super._value as _$MSSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$MSSInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSInitial implements MSSInitial {
  const _$MSSInitial({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.initial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MSSInitial &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$MSSInitialCopyWith<_$MSSInitial> get copyWith =>
      __$$MSSInitialCopyWithImpl<_$MSSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(MainScreenProps props, Failure failure)
        pricesError,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class MSSInitial implements MainScreenState {
  const factory MSSInitial({required final MainScreenProps props}) =
      _$MSSInitial;

  @override
  MainScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$MSSInitialCopyWith<_$MSSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MSSPricesLoadingCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory _$$MSSPricesLoadingCopyWith(
          _$MSSPricesLoading value, $Res Function(_$MSSPricesLoading) then) =
      __$$MSSPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$MSSPricesLoadingCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements _$$MSSPricesLoadingCopyWith<$Res> {
  __$$MSSPricesLoadingCopyWithImpl(
      _$MSSPricesLoading _value, $Res Function(_$MSSPricesLoading) _then)
      : super(_value, (v) => _then(v as _$MSSPricesLoading));

  @override
  _$MSSPricesLoading get _value => super._value as _$MSSPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$MSSPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSPricesLoading implements MSSPricesLoading {
  const _$MSSPricesLoading({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.pricesLoading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MSSPricesLoading &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$MSSPricesLoadingCopyWith<_$MSSPricesLoading> get copyWith =>
      __$$MSSPricesLoadingCopyWithImpl<_$MSSPricesLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(MainScreenProps props, Failure failure)
        pricesError,
  }) {
    return pricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
  }) {
    return pricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return pricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return pricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(this);
    }
    return orElse();
  }
}

abstract class MSSPricesLoading implements MainScreenState {
  const factory MSSPricesLoading({required final MainScreenProps props}) =
      _$MSSPricesLoading;

  @override
  MainScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$MSSPricesLoadingCopyWith<_$MSSPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MSSNextPricesLoadingCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory _$$MSSNextPricesLoadingCopyWith(_$MSSNextPricesLoading value,
          $Res Function(_$MSSNextPricesLoading) then) =
      __$$MSSNextPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$MSSNextPricesLoadingCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements _$$MSSNextPricesLoadingCopyWith<$Res> {
  __$$MSSNextPricesLoadingCopyWithImpl(_$MSSNextPricesLoading _value,
      $Res Function(_$MSSNextPricesLoading) _then)
      : super(_value, (v) => _then(v as _$MSSNextPricesLoading));

  @override
  _$MSSNextPricesLoading get _value => super._value as _$MSSNextPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$MSSNextPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSNextPricesLoading implements MSSNextPricesLoading {
  const _$MSSNextPricesLoading({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.nextPricesLoading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MSSNextPricesLoading &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$MSSNextPricesLoadingCopyWith<_$MSSNextPricesLoading> get copyWith =>
      __$$MSSNextPricesLoadingCopyWithImpl<_$MSSNextPricesLoading>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(MainScreenProps props, Failure failure)
        pricesError,
  }) {
    return nextPricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
  }) {
    return nextPricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return nextPricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return nextPricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(this);
    }
    return orElse();
  }
}

abstract class MSSNextPricesLoading implements MainScreenState {
  const factory MSSNextPricesLoading({required final MainScreenProps props}) =
      _$MSSNextPricesLoading;

  @override
  MainScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$MSSNextPricesLoadingCopyWith<_$MSSNextPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MSSPricesCompletedCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory _$$MSSPricesCompletedCopyWith(_$MSSPricesCompleted value,
          $Res Function(_$MSSPricesCompleted) then) =
      __$$MSSPricesCompletedCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$MSSPricesCompletedCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements _$$MSSPricesCompletedCopyWith<$Res> {
  __$$MSSPricesCompletedCopyWithImpl(
      _$MSSPricesCompleted _value, $Res Function(_$MSSPricesCompleted) _then)
      : super(_value, (v) => _then(v as _$MSSPricesCompleted));

  @override
  _$MSSPricesCompleted get _value => super._value as _$MSSPricesCompleted;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$MSSPricesCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
    ));
  }
}

/// @nodoc

class _$MSSPricesCompleted implements MSSPricesCompleted {
  const _$MSSPricesCompleted({required this.props});

  @override
  final MainScreenProps props;

  @override
  String toString() {
    return 'MainScreenState.pricesCompleted(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MSSPricesCompleted &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$MSSPricesCompletedCopyWith<_$MSSPricesCompleted> get copyWith =>
      __$$MSSPricesCompletedCopyWithImpl<_$MSSPricesCompleted>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(MainScreenProps props, Failure failure)
        pricesError,
  }) {
    return pricesCompleted(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
  }) {
    return pricesCompleted?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return pricesCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return pricesCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(this);
    }
    return orElse();
  }
}

abstract class MSSPricesCompleted implements MainScreenState {
  const factory MSSPricesCompleted({required final MainScreenProps props}) =
      _$MSSPricesCompleted;

  @override
  MainScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$MSSPricesCompletedCopyWith<_$MSSPricesCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MSSPricesErrorCopyWith<$Res>
    implements $MainScreenStateCopyWith<$Res> {
  factory _$$MSSPricesErrorCopyWith(
          _$MSSPricesError value, $Res Function(_$MSSPricesError) then) =
      __$$MSSPricesErrorCopyWithImpl<$Res>;
  @override
  $Res call({MainScreenProps props, Failure failure});

  @override
  $MainScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$MSSPricesErrorCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res>
    implements _$$MSSPricesErrorCopyWith<$Res> {
  __$$MSSPricesErrorCopyWithImpl(
      _$MSSPricesError _value, $Res Function(_$MSSPricesError) _then)
      : super(_value, (v) => _then(v as _$MSSPricesError));

  @override
  _$MSSPricesError get _value => super._value as _$MSSPricesError;

  @override
  $Res call({
    Object? props = freezed,
    Object? failure = freezed,
  }) {
    return _then(_$MSSPricesError(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as MainScreenProps,
      failure: failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure,
    ));
  }
}

/// @nodoc

class _$MSSPricesError implements MSSPricesError {
  const _$MSSPricesError({required this.props, required this.failure});

  @override
  final MainScreenProps props;
  @override
  final Failure failure;

  @override
  String toString() {
    return 'MainScreenState.pricesError(props: $props, failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MSSPricesError &&
            const DeepCollectionEquality().equals(other.props, props) &&
            const DeepCollectionEquality().equals(other.failure, failure));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(props),
      const DeepCollectionEquality().hash(failure));

  @JsonKey(ignore: true)
  @override
  _$$MSSPricesErrorCopyWith<_$MSSPricesError> get copyWith =>
      __$$MSSPricesErrorCopyWithImpl<_$MSSPricesError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(MainScreenProps props) initial,
    required TResult Function(MainScreenProps props) pricesLoading,
    required TResult Function(MainScreenProps props) nextPricesLoading,
    required TResult Function(MainScreenProps props) pricesCompleted,
    required TResult Function(MainScreenProps props, Failure failure)
        pricesError,
  }) {
    return pricesError(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
  }) {
    return pricesError?.call(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(MainScreenProps props)? initial,
    TResult Function(MainScreenProps props)? pricesLoading,
    TResult Function(MainScreenProps props)? nextPricesLoading,
    TResult Function(MainScreenProps props)? pricesCompleted,
    TResult Function(MainScreenProps props, Failure failure)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(props, failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MSSInitial value) initial,
    required TResult Function(MSSPricesLoading value) pricesLoading,
    required TResult Function(MSSNextPricesLoading value) nextPricesLoading,
    required TResult Function(MSSPricesCompleted value) pricesCompleted,
    required TResult Function(MSSPricesError value) pricesError,
  }) {
    return pricesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
  }) {
    return pricesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MSSInitial value)? initial,
    TResult Function(MSSPricesLoading value)? pricesLoading,
    TResult Function(MSSNextPricesLoading value)? nextPricesLoading,
    TResult Function(MSSPricesCompleted value)? pricesCompleted,
    TResult Function(MSSPricesError value)? pricesError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(this);
    }
    return orElse();
  }
}

abstract class MSSPricesError implements MainScreenState {
  const factory MSSPricesError(
      {required final MainScreenProps props,
      required final Failure failure}) = _$MSSPricesError;

  @override
  MainScreenProps get props => throw _privateConstructorUsedError;
  Failure get failure => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$MSSPricesErrorCopyWith<_$MSSPricesError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MainScreenProps {
  bool get isMainHeaderVisible => throw _privateConstructorUsedError;
  List<Produce> get produceList => throw _privateConstructorUsedError;
  FarmhubUser? get farmhubUser => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MainScreenPropsCopyWith<MainScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenPropsCopyWith<$Res> {
  factory $MainScreenPropsCopyWith(
          MainScreenProps value, $Res Function(MainScreenProps) then) =
      _$MainScreenPropsCopyWithImpl<$Res>;
  $Res call(
      {bool isMainHeaderVisible,
      List<Produce> produceList,
      FarmhubUser? farmhubUser});

  $FarmhubUserCopyWith<$Res>? get farmhubUser;
}

/// @nodoc
class _$MainScreenPropsCopyWithImpl<$Res>
    implements $MainScreenPropsCopyWith<$Res> {
  _$MainScreenPropsCopyWithImpl(this._value, this._then);

  final MainScreenProps _value;
  // ignore: unused_field
  final $Res Function(MainScreenProps) _then;

  @override
  $Res call({
    Object? isMainHeaderVisible = freezed,
    Object? produceList = freezed,
    Object? farmhubUser = freezed,
  }) {
    return _then(_value.copyWith(
      isMainHeaderVisible: isMainHeaderVisible == freezed
          ? _value.isMainHeaderVisible
          : isMainHeaderVisible // ignore: cast_nullable_to_non_nullable
              as bool,
      produceList: produceList == freezed
          ? _value.produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
      farmhubUser: farmhubUser == freezed
          ? _value.farmhubUser
          : farmhubUser // ignore: cast_nullable_to_non_nullable
              as FarmhubUser?,
    ));
  }

  @override
  $FarmhubUserCopyWith<$Res>? get farmhubUser {
    if (_value.farmhubUser == null) {
      return null;
    }

    return $FarmhubUserCopyWith<$Res>(_value.farmhubUser!, (value) {
      return _then(_value.copyWith(farmhubUser: value));
    });
  }
}

/// @nodoc
abstract class _$$_MainScreenPropsCopyWith<$Res>
    implements $MainScreenPropsCopyWith<$Res> {
  factory _$$_MainScreenPropsCopyWith(
          _$_MainScreenProps value, $Res Function(_$_MainScreenProps) then) =
      __$$_MainScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool isMainHeaderVisible,
      List<Produce> produceList,
      FarmhubUser? farmhubUser});

  @override
  $FarmhubUserCopyWith<$Res>? get farmhubUser;
}

/// @nodoc
class __$$_MainScreenPropsCopyWithImpl<$Res>
    extends _$MainScreenPropsCopyWithImpl<$Res>
    implements _$$_MainScreenPropsCopyWith<$Res> {
  __$$_MainScreenPropsCopyWithImpl(
      _$_MainScreenProps _value, $Res Function(_$_MainScreenProps) _then)
      : super(_value, (v) => _then(v as _$_MainScreenProps));

  @override
  _$_MainScreenProps get _value => super._value as _$_MainScreenProps;

  @override
  $Res call({
    Object? isMainHeaderVisible = freezed,
    Object? produceList = freezed,
    Object? farmhubUser = freezed,
  }) {
    return _then(_$_MainScreenProps(
      isMainHeaderVisible: isMainHeaderVisible == freezed
          ? _value.isMainHeaderVisible
          : isMainHeaderVisible // ignore: cast_nullable_to_non_nullable
              as bool,
      produceList: produceList == freezed
          ? _value._produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
      farmhubUser: farmhubUser == freezed
          ? _value.farmhubUser
          : farmhubUser // ignore: cast_nullable_to_non_nullable
              as FarmhubUser?,
    ));
  }
}

/// @nodoc

class _$_MainScreenProps implements _MainScreenProps {
  const _$_MainScreenProps(
      {required this.isMainHeaderVisible,
      required final List<Produce> produceList,
      required this.farmhubUser})
      : _produceList = produceList;

  @override
  final bool isMainHeaderVisible;
  final List<Produce> _produceList;
  @override
  List<Produce> get produceList {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_produceList);
  }

  @override
  final FarmhubUser? farmhubUser;

  @override
  String toString() {
    return 'MainScreenProps(isMainHeaderVisible: $isMainHeaderVisible, produceList: $produceList, farmhubUser: $farmhubUser)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MainScreenProps &&
            const DeepCollectionEquality()
                .equals(other.isMainHeaderVisible, isMainHeaderVisible) &&
            const DeepCollectionEquality()
                .equals(other._produceList, _produceList) &&
            const DeepCollectionEquality()
                .equals(other.farmhubUser, farmhubUser));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isMainHeaderVisible),
      const DeepCollectionEquality().hash(_produceList),
      const DeepCollectionEquality().hash(farmhubUser));

  @JsonKey(ignore: true)
  @override
  _$$_MainScreenPropsCopyWith<_$_MainScreenProps> get copyWith =>
      __$$_MainScreenPropsCopyWithImpl<_$_MainScreenProps>(this, _$identity);
}

abstract class _MainScreenProps implements MainScreenProps {
  const factory _MainScreenProps(
      {required final bool isMainHeaderVisible,
      required final List<Produce> produceList,
      required final FarmhubUser? farmhubUser}) = _$_MainScreenProps;

  @override
  bool get isMainHeaderVisible => throw _privateConstructorUsedError;
  @override
  List<Produce> get produceList => throw _privateConstructorUsedError;
  @override
  FarmhubUser? get farmhubUser => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_MainScreenPropsCopyWith<_$_MainScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'add_new_price_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AddNewPriceScreenEventTearOff {
  const _$AddNewPriceScreenEventTearOff();

  _ANPEStarted started() {
    return const _ANPEStarted();
  }

  _ANPEGetFirstTenProduce getFirstTenProduce() {
    return const _ANPEGetFirstTenProduce();
  }

  _ANPEGetNextTenProduce getNextTenProduce() {
    return const _ANPEGetNextTenProduce();
  }

  _ANPEExecAddNewPrice execAddNewPrice({required Produce produce}) {
    return _ANPEExecAddNewPrice(
      produce: produce,
    );
  }
}

/// @nodoc
const $AddNewPriceScreenEvent = _$AddNewPriceScreenEventTearOff();

/// @nodoc
mixin _$AddNewPriceScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddNewPriceScreenEventCopyWith<$Res> {
  factory $AddNewPriceScreenEventCopyWith(AddNewPriceScreenEvent value,
          $Res Function(AddNewPriceScreenEvent) then) =
      _$AddNewPriceScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements $AddNewPriceScreenEventCopyWith<$Res> {
  _$AddNewPriceScreenEventCopyWithImpl(this._value, this._then);

  final AddNewPriceScreenEvent _value;
  // ignore: unused_field
  final $Res Function(AddNewPriceScreenEvent) _then;
}

/// @nodoc
abstract class _$ANPEStartedCopyWith<$Res> {
  factory _$ANPEStartedCopyWith(
          _ANPEStarted value, $Res Function(_ANPEStarted) then) =
      __$ANPEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$ANPEStartedCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$ANPEStartedCopyWith<$Res> {
  __$ANPEStartedCopyWithImpl(
      _ANPEStarted _value, $Res Function(_ANPEStarted) _then)
      : super(_value, (v) => _then(v as _ANPEStarted));

  @override
  _ANPEStarted get _value => super._value as _ANPEStarted;
}

/// @nodoc

class _$_ANPEStarted with DiagnosticableTreeMixin implements _ANPEStarted {
  const _$_ANPEStarted();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.started()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenEvent.started'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ANPEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _ANPEStarted implements AddNewPriceScreenEvent {
  const factory _ANPEStarted() = _$_ANPEStarted;
}

/// @nodoc
abstract class _$ANPEGetFirstTenProduceCopyWith<$Res> {
  factory _$ANPEGetFirstTenProduceCopyWith(_ANPEGetFirstTenProduce value,
          $Res Function(_ANPEGetFirstTenProduce) then) =
      __$ANPEGetFirstTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$ANPEGetFirstTenProduceCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$ANPEGetFirstTenProduceCopyWith<$Res> {
  __$ANPEGetFirstTenProduceCopyWithImpl(_ANPEGetFirstTenProduce _value,
      $Res Function(_ANPEGetFirstTenProduce) _then)
      : super(_value, (v) => _then(v as _ANPEGetFirstTenProduce));

  @override
  _ANPEGetFirstTenProduce get _value => super._value as _ANPEGetFirstTenProduce;
}

/// @nodoc

class _$_ANPEGetFirstTenProduce
    with DiagnosticableTreeMixin
    implements _ANPEGetFirstTenProduce {
  const _$_ANPEGetFirstTenProduce();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.getFirstTenProduce()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenEvent.getFirstTenProduce'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ANPEGetFirstTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return getFirstTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return getFirstTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return getFirstTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return getFirstTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce(this);
    }
    return orElse();
  }
}

abstract class _ANPEGetFirstTenProduce implements AddNewPriceScreenEvent {
  const factory _ANPEGetFirstTenProduce() = _$_ANPEGetFirstTenProduce;
}

/// @nodoc
abstract class _$ANPEGetNextTenProduceCopyWith<$Res> {
  factory _$ANPEGetNextTenProduceCopyWith(_ANPEGetNextTenProduce value,
          $Res Function(_ANPEGetNextTenProduce) then) =
      __$ANPEGetNextTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$ANPEGetNextTenProduceCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$ANPEGetNextTenProduceCopyWith<$Res> {
  __$ANPEGetNextTenProduceCopyWithImpl(_ANPEGetNextTenProduce _value,
      $Res Function(_ANPEGetNextTenProduce) _then)
      : super(_value, (v) => _then(v as _ANPEGetNextTenProduce));

  @override
  _ANPEGetNextTenProduce get _value => super._value as _ANPEGetNextTenProduce;
}

/// @nodoc

class _$_ANPEGetNextTenProduce
    with DiagnosticableTreeMixin
    implements _ANPEGetNextTenProduce {
  const _$_ANPEGetNextTenProduce();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.getNextTenProduce()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenEvent.getNextTenProduce'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ANPEGetNextTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return getNextTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return getNextTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return getNextTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return getNextTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce(this);
    }
    return orElse();
  }
}

abstract class _ANPEGetNextTenProduce implements AddNewPriceScreenEvent {
  const factory _ANPEGetNextTenProduce() = _$_ANPEGetNextTenProduce;
}

/// @nodoc
abstract class _$ANPEExecAddNewPriceCopyWith<$Res> {
  factory _$ANPEExecAddNewPriceCopyWith(_ANPEExecAddNewPrice value,
          $Res Function(_ANPEExecAddNewPrice) then) =
      __$ANPEExecAddNewPriceCopyWithImpl<$Res>;
  $Res call({Produce produce});

  $ProduceCopyWith<$Res> get produce;
}

/// @nodoc
class __$ANPEExecAddNewPriceCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$ANPEExecAddNewPriceCopyWith<$Res> {
  __$ANPEExecAddNewPriceCopyWithImpl(
      _ANPEExecAddNewPrice _value, $Res Function(_ANPEExecAddNewPrice) _then)
      : super(_value, (v) => _then(v as _ANPEExecAddNewPrice));

  @override
  _ANPEExecAddNewPrice get _value => super._value as _ANPEExecAddNewPrice;

  @override
  $Res call({
    Object? produce = freezed,
  }) {
    return _then(_ANPEExecAddNewPrice(
      produce: produce == freezed
          ? _value.produce
          : produce // ignore: cast_nullable_to_non_nullable
              as Produce,
    ));
  }

  @override
  $ProduceCopyWith<$Res> get produce {
    return $ProduceCopyWith<$Res>(_value.produce, (value) {
      return _then(_value.copyWith(produce: value));
    });
  }
}

/// @nodoc

class _$_ANPEExecAddNewPrice
    with DiagnosticableTreeMixin
    implements _ANPEExecAddNewPrice {
  const _$_ANPEExecAddNewPrice({required this.produce});

  @override
  final Produce produce;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.execAddNewPrice(produce: $produce)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
          DiagnosticsProperty('type', 'AddNewPriceScreenEvent.execAddNewPrice'))
      ..add(DiagnosticsProperty('produce', produce));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ANPEExecAddNewPrice &&
            (identical(other.produce, produce) || other.produce == produce));
  }

  @override
  int get hashCode => Object.hash(runtimeType, produce);

  @JsonKey(ignore: true)
  @override
  _$ANPEExecAddNewPriceCopyWith<_ANPEExecAddNewPrice> get copyWith =>
      __$ANPEExecAddNewPriceCopyWithImpl<_ANPEExecAddNewPrice>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return execAddNewPrice(produce);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return execAddNewPrice?.call(produce);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (execAddNewPrice != null) {
      return execAddNewPrice(produce);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return execAddNewPrice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return execAddNewPrice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (execAddNewPrice != null) {
      return execAddNewPrice(this);
    }
    return orElse();
  }
}

abstract class _ANPEExecAddNewPrice implements AddNewPriceScreenEvent {
  const factory _ANPEExecAddNewPrice({required Produce produce}) =
      _$_ANPEExecAddNewPrice;

  Produce get produce;
  @JsonKey(ignore: true)
  _$ANPEExecAddNewPriceCopyWith<_ANPEExecAddNewPrice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AddNewPriceScreenStateTearOff {
  const _$AddNewPriceScreenStateTearOff();

  ANPSInitial initial({required AddNewPriceScreenProps props}) {
    return ANPSInitial(
      props: props,
    );
  }

  ANPSPricesLoading pricesLoading({required AddNewPriceScreenProps props}) {
    return ANPSPricesLoading(
      props: props,
    );
  }

  ANPSNextPricesLoading nextPricesLoading(
      {required AddNewPriceScreenProps props}) {
    return ANPSNextPricesLoading(
      props: props,
    );
  }

  ANPSPricesCompleted pricesCompleted({required AddNewPriceScreenProps props}) {
    return ANPSPricesCompleted(
      props: props,
    );
  }

  ANPSPricesError pricesError(
      {required String message,
      required String code,
      required StackTrace stackTrace,
      required AddNewPriceScreenProps props}) {
    return ANPSPricesError(
      message: message,
      code: code,
      stackTrace: stackTrace,
      props: props,
    );
  }

  ANPSAddNewPriceSuccess addNewPriceSuccess(
      {required Produce produce, required AddNewPriceScreenProps props}) {
    return ANPSAddNewPriceSuccess(
      produce: produce,
      props: props,
    );
  }

  ANPSAddNewPriceError addNewPriceError(
      {required AddNewPriceScreenProps props, required Failure failure}) {
    return ANPSAddNewPriceError(
      props: props,
      failure: failure,
    );
  }
}

/// @nodoc
const $AddNewPriceScreenState = _$AddNewPriceScreenStateTearOff();

/// @nodoc
mixin _$AddNewPriceScreenState {
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddNewPriceScreenStateCopyWith<AddNewPriceScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddNewPriceScreenStateCopyWith<$Res> {
  factory $AddNewPriceScreenStateCopyWith(AddNewPriceScreenState value,
          $Res Function(AddNewPriceScreenState) then) =
      _$AddNewPriceScreenStateCopyWithImpl<$Res>;
  $Res call({AddNewPriceScreenProps props});

  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  _$AddNewPriceScreenStateCopyWithImpl(this._value, this._then);

  final AddNewPriceScreenState _value;
  // ignore: unused_field
  final $Res Function(AddNewPriceScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props {
    return $AddNewPriceScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class $ANPSInitialCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory $ANPSInitialCopyWith(
          ANPSInitial value, $Res Function(ANPSInitial) then) =
      _$ANPSInitialCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ANPSInitialCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $ANPSInitialCopyWith<$Res> {
  _$ANPSInitialCopyWithImpl(
      ANPSInitial _value, $Res Function(ANPSInitial) _then)
      : super(_value, (v) => _then(v as ANPSInitial));

  @override
  ANPSInitial get _value => super._value as ANPSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(ANPSInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSInitial with DiagnosticableTreeMixin implements ANPSInitial {
  const _$ANPSInitial({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.initial(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenState.initial'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ANPSInitial &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $ANPSInitialCopyWith<ANPSInitial> get copyWith =>
      _$ANPSInitialCopyWithImpl<ANPSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ANPSInitial implements AddNewPriceScreenState {
  const factory ANPSInitial({required AddNewPriceScreenProps props}) =
      _$ANPSInitial;

  @override
  AddNewPriceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $ANPSInitialCopyWith<ANPSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ANPSPricesLoadingCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory $ANPSPricesLoadingCopyWith(
          ANPSPricesLoading value, $Res Function(ANPSPricesLoading) then) =
      _$ANPSPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ANPSPricesLoadingCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $ANPSPricesLoadingCopyWith<$Res> {
  _$ANPSPricesLoadingCopyWithImpl(
      ANPSPricesLoading _value, $Res Function(ANPSPricesLoading) _then)
      : super(_value, (v) => _then(v as ANPSPricesLoading));

  @override
  ANPSPricesLoading get _value => super._value as ANPSPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(ANPSPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSPricesLoading
    with DiagnosticableTreeMixin
    implements ANPSPricesLoading {
  const _$ANPSPricesLoading({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.pricesLoading(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenState.pricesLoading'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ANPSPricesLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $ANPSPricesLoadingCopyWith<ANPSPricesLoading> get copyWith =>
      _$ANPSPricesLoadingCopyWithImpl<ANPSPricesLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return pricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return pricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return pricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return pricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(this);
    }
    return orElse();
  }
}

abstract class ANPSPricesLoading implements AddNewPriceScreenState {
  const factory ANPSPricesLoading({required AddNewPriceScreenProps props}) =
      _$ANPSPricesLoading;

  @override
  AddNewPriceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $ANPSPricesLoadingCopyWith<ANPSPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ANPSNextPricesLoadingCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory $ANPSNextPricesLoadingCopyWith(ANPSNextPricesLoading value,
          $Res Function(ANPSNextPricesLoading) then) =
      _$ANPSNextPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ANPSNextPricesLoadingCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $ANPSNextPricesLoadingCopyWith<$Res> {
  _$ANPSNextPricesLoadingCopyWithImpl(
      ANPSNextPricesLoading _value, $Res Function(ANPSNextPricesLoading) _then)
      : super(_value, (v) => _then(v as ANPSNextPricesLoading));

  @override
  ANPSNextPricesLoading get _value => super._value as ANPSNextPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(ANPSNextPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSNextPricesLoading
    with DiagnosticableTreeMixin
    implements ANPSNextPricesLoading {
  const _$ANPSNextPricesLoading({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.nextPricesLoading(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenState.nextPricesLoading'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ANPSNextPricesLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $ANPSNextPricesLoadingCopyWith<ANPSNextPricesLoading> get copyWith =>
      _$ANPSNextPricesLoadingCopyWithImpl<ANPSNextPricesLoading>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return nextPricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return nextPricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return nextPricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return nextPricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(this);
    }
    return orElse();
  }
}

abstract class ANPSNextPricesLoading implements AddNewPriceScreenState {
  const factory ANPSNextPricesLoading({required AddNewPriceScreenProps props}) =
      _$ANPSNextPricesLoading;

  @override
  AddNewPriceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $ANPSNextPricesLoadingCopyWith<ANPSNextPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ANPSPricesCompletedCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory $ANPSPricesCompletedCopyWith(
          ANPSPricesCompleted value, $Res Function(ANPSPricesCompleted) then) =
      _$ANPSPricesCompletedCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ANPSPricesCompletedCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $ANPSPricesCompletedCopyWith<$Res> {
  _$ANPSPricesCompletedCopyWithImpl(
      ANPSPricesCompleted _value, $Res Function(ANPSPricesCompleted) _then)
      : super(_value, (v) => _then(v as ANPSPricesCompleted));

  @override
  ANPSPricesCompleted get _value => super._value as ANPSPricesCompleted;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(ANPSPricesCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSPricesCompleted
    with DiagnosticableTreeMixin
    implements ANPSPricesCompleted {
  const _$ANPSPricesCompleted({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.pricesCompleted(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
          DiagnosticsProperty('type', 'AddNewPriceScreenState.pricesCompleted'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ANPSPricesCompleted &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  $ANPSPricesCompletedCopyWith<ANPSPricesCompleted> get copyWith =>
      _$ANPSPricesCompletedCopyWithImpl<ANPSPricesCompleted>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return pricesCompleted(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return pricesCompleted?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return pricesCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return pricesCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(this);
    }
    return orElse();
  }
}

abstract class ANPSPricesCompleted implements AddNewPriceScreenState {
  const factory ANPSPricesCompleted({required AddNewPriceScreenProps props}) =
      _$ANPSPricesCompleted;

  @override
  AddNewPriceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $ANPSPricesCompletedCopyWith<ANPSPricesCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ANPSPricesErrorCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory $ANPSPricesErrorCopyWith(
          ANPSPricesError value, $Res Function(ANPSPricesError) then) =
      _$ANPSPricesErrorCopyWithImpl<$Res>;
  @override
  $Res call(
      {String message,
      String code,
      StackTrace stackTrace,
      AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ANPSPricesErrorCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $ANPSPricesErrorCopyWith<$Res> {
  _$ANPSPricesErrorCopyWithImpl(
      ANPSPricesError _value, $Res Function(ANPSPricesError) _then)
      : super(_value, (v) => _then(v as ANPSPricesError));

  @override
  ANPSPricesError get _value => super._value as ANPSPricesError;

  @override
  $Res call({
    Object? message = freezed,
    Object? code = freezed,
    Object? stackTrace = freezed,
    Object? props = freezed,
  }) {
    return _then(ANPSPricesError(
      message: message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      stackTrace: stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSPricesError
    with DiagnosticableTreeMixin
    implements ANPSPricesError {
  const _$ANPSPricesError(
      {required this.message,
      required this.code,
      required this.stackTrace,
      required this.props});

  @override
  final String message;
  @override
  final String code;
  @override
  final StackTrace stackTrace;
  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.pricesError(message: $message, code: $code, stackTrace: $stackTrace, props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenState.pricesError'))
      ..add(DiagnosticsProperty('message', message))
      ..add(DiagnosticsProperty('code', code))
      ..add(DiagnosticsProperty('stackTrace', stackTrace))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ANPSPricesError &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, message, code, stackTrace, props);

  @JsonKey(ignore: true)
  @override
  $ANPSPricesErrorCopyWith<ANPSPricesError> get copyWith =>
      _$ANPSPricesErrorCopyWithImpl<ANPSPricesError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return pricesError(message, code, stackTrace, props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return pricesError?.call(message, code, stackTrace, props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(message, code, stackTrace, props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return pricesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return pricesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(this);
    }
    return orElse();
  }
}

abstract class ANPSPricesError implements AddNewPriceScreenState {
  const factory ANPSPricesError(
      {required String message,
      required String code,
      required StackTrace stackTrace,
      required AddNewPriceScreenProps props}) = _$ANPSPricesError;

  String get message;
  String get code;
  StackTrace get stackTrace;
  @override
  AddNewPriceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $ANPSPricesErrorCopyWith<ANPSPricesError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ANPSAddNewPriceSuccessCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory $ANPSAddNewPriceSuccessCopyWith(ANPSAddNewPriceSuccess value,
          $Res Function(ANPSAddNewPriceSuccess) then) =
      _$ANPSAddNewPriceSuccessCopyWithImpl<$Res>;
  @override
  $Res call({Produce produce, AddNewPriceScreenProps props});

  $ProduceCopyWith<$Res> get produce;
  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ANPSAddNewPriceSuccessCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $ANPSAddNewPriceSuccessCopyWith<$Res> {
  _$ANPSAddNewPriceSuccessCopyWithImpl(ANPSAddNewPriceSuccess _value,
      $Res Function(ANPSAddNewPriceSuccess) _then)
      : super(_value, (v) => _then(v as ANPSAddNewPriceSuccess));

  @override
  ANPSAddNewPriceSuccess get _value => super._value as ANPSAddNewPriceSuccess;

  @override
  $Res call({
    Object? produce = freezed,
    Object? props = freezed,
  }) {
    return _then(ANPSAddNewPriceSuccess(
      produce: produce == freezed
          ? _value.produce
          : produce // ignore: cast_nullable_to_non_nullable
              as Produce,
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }

  @override
  $ProduceCopyWith<$Res> get produce {
    return $ProduceCopyWith<$Res>(_value.produce, (value) {
      return _then(_value.copyWith(produce: value));
    });
  }
}

/// @nodoc

class _$ANPSAddNewPriceSuccess
    with DiagnosticableTreeMixin
    implements ANPSAddNewPriceSuccess {
  const _$ANPSAddNewPriceSuccess({required this.produce, required this.props});

  @override
  final Produce produce;
  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.addNewPriceSuccess(produce: $produce, props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenState.addNewPriceSuccess'))
      ..add(DiagnosticsProperty('produce', produce))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ANPSAddNewPriceSuccess &&
            (identical(other.produce, produce) || other.produce == produce) &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, produce, props);

  @JsonKey(ignore: true)
  @override
  $ANPSAddNewPriceSuccessCopyWith<ANPSAddNewPriceSuccess> get copyWith =>
      _$ANPSAddNewPriceSuccessCopyWithImpl<ANPSAddNewPriceSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return addNewPriceSuccess(produce, props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return addNewPriceSuccess?.call(produce, props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceSuccess != null) {
      return addNewPriceSuccess(produce, props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return addNewPriceSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return addNewPriceSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceSuccess != null) {
      return addNewPriceSuccess(this);
    }
    return orElse();
  }
}

abstract class ANPSAddNewPriceSuccess implements AddNewPriceScreenState {
  const factory ANPSAddNewPriceSuccess(
      {required Produce produce,
      required AddNewPriceScreenProps props}) = _$ANPSAddNewPriceSuccess;

  Produce get produce;
  @override
  AddNewPriceScreenProps get props;
  @override
  @JsonKey(ignore: true)
  $ANPSAddNewPriceSuccessCopyWith<ANPSAddNewPriceSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ANPSAddNewPriceErrorCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory $ANPSAddNewPriceErrorCopyWith(ANPSAddNewPriceError value,
          $Res Function(ANPSAddNewPriceError) then) =
      _$ANPSAddNewPriceErrorCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props, Failure failure});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$ANPSAddNewPriceErrorCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $ANPSAddNewPriceErrorCopyWith<$Res> {
  _$ANPSAddNewPriceErrorCopyWithImpl(
      ANPSAddNewPriceError _value, $Res Function(ANPSAddNewPriceError) _then)
      : super(_value, (v) => _then(v as ANPSAddNewPriceError));

  @override
  ANPSAddNewPriceError get _value => super._value as ANPSAddNewPriceError;

  @override
  $Res call({
    Object? props = freezed,
    Object? failure = freezed,
  }) {
    return _then(ANPSAddNewPriceError(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
      failure: failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure,
    ));
  }
}

/// @nodoc

class _$ANPSAddNewPriceError
    with DiagnosticableTreeMixin
    implements ANPSAddNewPriceError {
  const _$ANPSAddNewPriceError({required this.props, required this.failure});

  @override
  final AddNewPriceScreenProps props;
  @override
  final Failure failure;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.addNewPriceError(props: $props, failure: $failure)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenState.addNewPriceError'))
      ..add(DiagnosticsProperty('props', props))
      ..add(DiagnosticsProperty('failure', failure));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ANPSAddNewPriceError &&
            (identical(other.props, props) || other.props == props) &&
            (identical(other.failure, failure) || other.failure == failure));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props, failure);

  @JsonKey(ignore: true)
  @override
  $ANPSAddNewPriceErrorCopyWith<ANPSAddNewPriceError> get copyWith =>
      _$ANPSAddNewPriceErrorCopyWithImpl<ANPSAddNewPriceError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return addNewPriceError(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return addNewPriceError?.call(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceError != null) {
      return addNewPriceError(props, failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return addNewPriceError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return addNewPriceError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceError != null) {
      return addNewPriceError(this);
    }
    return orElse();
  }
}

abstract class ANPSAddNewPriceError implements AddNewPriceScreenState {
  const factory ANPSAddNewPriceError(
      {required AddNewPriceScreenProps props,
      required Failure failure}) = _$ANPSAddNewPriceError;

  @override
  AddNewPriceScreenProps get props;
  Failure get failure;
  @override
  @JsonKey(ignore: true)
  $ANPSAddNewPriceErrorCopyWith<ANPSAddNewPriceError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AddNewPriceScreenPropsTearOff {
  const _$AddNewPriceScreenPropsTearOff();

  _AddNewPriceScreenProps call({required List<Produce> produceList}) {
    return _AddNewPriceScreenProps(
      produceList: produceList,
    );
  }
}

/// @nodoc
const $AddNewPriceScreenProps = _$AddNewPriceScreenPropsTearOff();

/// @nodoc
mixin _$AddNewPriceScreenProps {
  List<Produce> get produceList => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddNewPriceScreenPropsCopyWith<AddNewPriceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddNewPriceScreenPropsCopyWith<$Res> {
  factory $AddNewPriceScreenPropsCopyWith(AddNewPriceScreenProps value,
          $Res Function(AddNewPriceScreenProps) then) =
      _$AddNewPriceScreenPropsCopyWithImpl<$Res>;
  $Res call({List<Produce> produceList});
}

/// @nodoc
class _$AddNewPriceScreenPropsCopyWithImpl<$Res>
    implements $AddNewPriceScreenPropsCopyWith<$Res> {
  _$AddNewPriceScreenPropsCopyWithImpl(this._value, this._then);

  final AddNewPriceScreenProps _value;
  // ignore: unused_field
  final $Res Function(AddNewPriceScreenProps) _then;

  @override
  $Res call({
    Object? produceList = freezed,
  }) {
    return _then(_value.copyWith(
      produceList: produceList == freezed
          ? _value.produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
    ));
  }
}

/// @nodoc
abstract class _$AddNewPriceScreenPropsCopyWith<$Res>
    implements $AddNewPriceScreenPropsCopyWith<$Res> {
  factory _$AddNewPriceScreenPropsCopyWith(_AddNewPriceScreenProps value,
          $Res Function(_AddNewPriceScreenProps) then) =
      __$AddNewPriceScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call({List<Produce> produceList});
}

/// @nodoc
class __$AddNewPriceScreenPropsCopyWithImpl<$Res>
    extends _$AddNewPriceScreenPropsCopyWithImpl<$Res>
    implements _$AddNewPriceScreenPropsCopyWith<$Res> {
  __$AddNewPriceScreenPropsCopyWithImpl(_AddNewPriceScreenProps _value,
      $Res Function(_AddNewPriceScreenProps) _then)
      : super(_value, (v) => _then(v as _AddNewPriceScreenProps));

  @override
  _AddNewPriceScreenProps get _value => super._value as _AddNewPriceScreenProps;

  @override
  $Res call({
    Object? produceList = freezed,
  }) {
    return _then(_AddNewPriceScreenProps(
      produceList: produceList == freezed
          ? _value.produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
    ));
  }
}

/// @nodoc

class _$_AddNewPriceScreenProps
    with DiagnosticableTreeMixin
    implements _AddNewPriceScreenProps {
  const _$_AddNewPriceScreenProps({required this.produceList});

  @override
  final List<Produce> produceList;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenProps(produceList: $produceList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenProps'))
      ..add(DiagnosticsProperty('produceList', produceList));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddNewPriceScreenProps &&
            const DeepCollectionEquality()
                .equals(other.produceList, produceList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(produceList));

  @JsonKey(ignore: true)
  @override
  _$AddNewPriceScreenPropsCopyWith<_AddNewPriceScreenProps> get copyWith =>
      __$AddNewPriceScreenPropsCopyWithImpl<_AddNewPriceScreenProps>(
          this, _$identity);
}

abstract class _AddNewPriceScreenProps implements AddNewPriceScreenProps {
  const factory _AddNewPriceScreenProps({required List<Produce> produceList}) =
      _$_AddNewPriceScreenProps;

  @override
  List<Produce> get produceList;
  @override
  @JsonKey(ignore: true)
  _$AddNewPriceScreenPropsCopyWith<_AddNewPriceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

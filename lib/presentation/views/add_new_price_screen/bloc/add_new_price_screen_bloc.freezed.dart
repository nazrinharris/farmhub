// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'add_new_price_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AddNewPriceScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddNewPriceScreenEventCopyWith<$Res> {
  factory $AddNewPriceScreenEventCopyWith(AddNewPriceScreenEvent value,
          $Res Function(AddNewPriceScreenEvent) then) =
      _$AddNewPriceScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements $AddNewPriceScreenEventCopyWith<$Res> {
  _$AddNewPriceScreenEventCopyWithImpl(this._value, this._then);

  final AddNewPriceScreenEvent _value;
  // ignore: unused_field
  final $Res Function(AddNewPriceScreenEvent) _then;
}

/// @nodoc
abstract class _$$_ANPEStartedCopyWith<$Res> {
  factory _$$_ANPEStartedCopyWith(
          _$_ANPEStarted value, $Res Function(_$_ANPEStarted) then) =
      __$$_ANPEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ANPEStartedCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$$_ANPEStartedCopyWith<$Res> {
  __$$_ANPEStartedCopyWithImpl(
      _$_ANPEStarted _value, $Res Function(_$_ANPEStarted) _then)
      : super(_value, (v) => _then(v as _$_ANPEStarted));

  @override
  _$_ANPEStarted get _value => super._value as _$_ANPEStarted;
}

/// @nodoc

class _$_ANPEStarted with DiagnosticableTreeMixin implements _ANPEStarted {
  const _$_ANPEStarted();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.started()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'AddNewPriceScreenEvent.started'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ANPEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _ANPEStarted implements AddNewPriceScreenEvent {
  const factory _ANPEStarted() = _$_ANPEStarted;
}

/// @nodoc
abstract class _$$_ANPEGetFirstTenProduceCopyWith<$Res> {
  factory _$$_ANPEGetFirstTenProduceCopyWith(_$_ANPEGetFirstTenProduce value,
          $Res Function(_$_ANPEGetFirstTenProduce) then) =
      __$$_ANPEGetFirstTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ANPEGetFirstTenProduceCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$$_ANPEGetFirstTenProduceCopyWith<$Res> {
  __$$_ANPEGetFirstTenProduceCopyWithImpl(_$_ANPEGetFirstTenProduce _value,
      $Res Function(_$_ANPEGetFirstTenProduce) _then)
      : super(_value, (v) => _then(v as _$_ANPEGetFirstTenProduce));

  @override
  _$_ANPEGetFirstTenProduce get _value =>
      super._value as _$_ANPEGetFirstTenProduce;
}

/// @nodoc

class _$_ANPEGetFirstTenProduce
    with DiagnosticableTreeMixin
    implements _ANPEGetFirstTenProduce {
  const _$_ANPEGetFirstTenProduce();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.getFirstTenProduce()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'AddNewPriceScreenEvent.getFirstTenProduce'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ANPEGetFirstTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return getFirstTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return getFirstTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return getFirstTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return getFirstTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getFirstTenProduce != null) {
      return getFirstTenProduce(this);
    }
    return orElse();
  }
}

abstract class _ANPEGetFirstTenProduce implements AddNewPriceScreenEvent {
  const factory _ANPEGetFirstTenProduce() = _$_ANPEGetFirstTenProduce;
}

/// @nodoc
abstract class _$$_ANPEGetNextTenProduceCopyWith<$Res> {
  factory _$$_ANPEGetNextTenProduceCopyWith(_$_ANPEGetNextTenProduce value,
          $Res Function(_$_ANPEGetNextTenProduce) then) =
      __$$_ANPEGetNextTenProduceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ANPEGetNextTenProduceCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$$_ANPEGetNextTenProduceCopyWith<$Res> {
  __$$_ANPEGetNextTenProduceCopyWithImpl(_$_ANPEGetNextTenProduce _value,
      $Res Function(_$_ANPEGetNextTenProduce) _then)
      : super(_value, (v) => _then(v as _$_ANPEGetNextTenProduce));

  @override
  _$_ANPEGetNextTenProduce get _value =>
      super._value as _$_ANPEGetNextTenProduce;
}

/// @nodoc

class _$_ANPEGetNextTenProduce
    with DiagnosticableTreeMixin
    implements _ANPEGetNextTenProduce {
  const _$_ANPEGetNextTenProduce();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.getNextTenProduce()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty(
        'type', 'AddNewPriceScreenEvent.getNextTenProduce'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ANPEGetNextTenProduce);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return getNextTenProduce();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return getNextTenProduce?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return getNextTenProduce(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return getNextTenProduce?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (getNextTenProduce != null) {
      return getNextTenProduce(this);
    }
    return orElse();
  }
}

abstract class _ANPEGetNextTenProduce implements AddNewPriceScreenEvent {
  const factory _ANPEGetNextTenProduce() = _$_ANPEGetNextTenProduce;
}

/// @nodoc
abstract class _$$_ANPEExecAddNewPriceCopyWith<$Res> {
  factory _$$_ANPEExecAddNewPriceCopyWith(_$_ANPEExecAddNewPrice value,
          $Res Function(_$_ANPEExecAddNewPrice) then) =
      __$$_ANPEExecAddNewPriceCopyWithImpl<$Res>;
  $Res call({Produce produce});

  $ProduceCopyWith<$Res> get produce;
}

/// @nodoc
class __$$_ANPEExecAddNewPriceCopyWithImpl<$Res>
    extends _$AddNewPriceScreenEventCopyWithImpl<$Res>
    implements _$$_ANPEExecAddNewPriceCopyWith<$Res> {
  __$$_ANPEExecAddNewPriceCopyWithImpl(_$_ANPEExecAddNewPrice _value,
      $Res Function(_$_ANPEExecAddNewPrice) _then)
      : super(_value, (v) => _then(v as _$_ANPEExecAddNewPrice));

  @override
  _$_ANPEExecAddNewPrice get _value => super._value as _$_ANPEExecAddNewPrice;

  @override
  $Res call({
    Object? produce = freezed,
  }) {
    return _then(_$_ANPEExecAddNewPrice(
      produce: produce == freezed
          ? _value.produce
          : produce // ignore: cast_nullable_to_non_nullable
              as Produce,
    ));
  }

  @override
  $ProduceCopyWith<$Res> get produce {
    return $ProduceCopyWith<$Res>(_value.produce, (value) {
      return _then(_value.copyWith(produce: value));
    });
  }
}

/// @nodoc

class _$_ANPEExecAddNewPrice
    with DiagnosticableTreeMixin
    implements _ANPEExecAddNewPrice {
  const _$_ANPEExecAddNewPrice({required this.produce});

  @override
  final Produce produce;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenEvent.execAddNewPrice(produce: $produce)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
          DiagnosticsProperty('type', 'AddNewPriceScreenEvent.execAddNewPrice'))
      ..add(DiagnosticsProperty('produce', produce));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ANPEExecAddNewPrice &&
            const DeepCollectionEquality().equals(other.produce, produce));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(produce));

  @JsonKey(ignore: true)
  @override
  _$$_ANPEExecAddNewPriceCopyWith<_$_ANPEExecAddNewPrice> get copyWith =>
      __$$_ANPEExecAddNewPriceCopyWithImpl<_$_ANPEExecAddNewPrice>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() getFirstTenProduce,
    required TResult Function() getNextTenProduce,
    required TResult Function(Produce produce) execAddNewPrice,
  }) {
    return execAddNewPrice(produce);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
  }) {
    return execAddNewPrice?.call(produce);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? getFirstTenProduce,
    TResult Function()? getNextTenProduce,
    TResult Function(Produce produce)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (execAddNewPrice != null) {
      return execAddNewPrice(produce);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ANPEStarted value) started,
    required TResult Function(_ANPEGetFirstTenProduce value) getFirstTenProduce,
    required TResult Function(_ANPEGetNextTenProduce value) getNextTenProduce,
    required TResult Function(_ANPEExecAddNewPrice value) execAddNewPrice,
  }) {
    return execAddNewPrice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
  }) {
    return execAddNewPrice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ANPEStarted value)? started,
    TResult Function(_ANPEGetFirstTenProduce value)? getFirstTenProduce,
    TResult Function(_ANPEGetNextTenProduce value)? getNextTenProduce,
    TResult Function(_ANPEExecAddNewPrice value)? execAddNewPrice,
    required TResult orElse(),
  }) {
    if (execAddNewPrice != null) {
      return execAddNewPrice(this);
    }
    return orElse();
  }
}

abstract class _ANPEExecAddNewPrice implements AddNewPriceScreenEvent {
  const factory _ANPEExecAddNewPrice({required final Produce produce}) =
      _$_ANPEExecAddNewPrice;

  Produce get produce => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_ANPEExecAddNewPriceCopyWith<_$_ANPEExecAddNewPrice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddNewPriceScreenState {
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddNewPriceScreenStateCopyWith<AddNewPriceScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddNewPriceScreenStateCopyWith<$Res> {
  factory $AddNewPriceScreenStateCopyWith(AddNewPriceScreenState value,
          $Res Function(AddNewPriceScreenState) then) =
      _$AddNewPriceScreenStateCopyWithImpl<$Res>;
  $Res call({AddNewPriceScreenProps props});

  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  _$AddNewPriceScreenStateCopyWithImpl(this._value, this._then);

  final AddNewPriceScreenState _value;
  // ignore: unused_field
  final $Res Function(AddNewPriceScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props {
    return $AddNewPriceScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class _$$ANPSInitialCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory _$$ANPSInitialCopyWith(
          _$ANPSInitial value, $Res Function(_$ANPSInitial) then) =
      __$$ANPSInitialCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$ANPSInitialCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements _$$ANPSInitialCopyWith<$Res> {
  __$$ANPSInitialCopyWithImpl(
      _$ANPSInitial _value, $Res Function(_$ANPSInitial) _then)
      : super(_value, (v) => _then(v as _$ANPSInitial));

  @override
  _$ANPSInitial get _value => super._value as _$ANPSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$ANPSInitial(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSInitial with DiagnosticableTreeMixin implements ANPSInitial {
  const _$ANPSInitial({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.initial(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenState.initial'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ANPSInitial &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$ANPSInitialCopyWith<_$ANPSInitial> get copyWith =>
      __$$ANPSInitialCopyWithImpl<_$ANPSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ANPSInitial implements AddNewPriceScreenState {
  const factory ANPSInitial({required final AddNewPriceScreenProps props}) =
      _$ANPSInitial;

  @override
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ANPSInitialCopyWith<_$ANPSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ANPSPricesLoadingCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory _$$ANPSPricesLoadingCopyWith(
          _$ANPSPricesLoading value, $Res Function(_$ANPSPricesLoading) then) =
      __$$ANPSPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$ANPSPricesLoadingCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements _$$ANPSPricesLoadingCopyWith<$Res> {
  __$$ANPSPricesLoadingCopyWithImpl(
      _$ANPSPricesLoading _value, $Res Function(_$ANPSPricesLoading) _then)
      : super(_value, (v) => _then(v as _$ANPSPricesLoading));

  @override
  _$ANPSPricesLoading get _value => super._value as _$ANPSPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$ANPSPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSPricesLoading
    with DiagnosticableTreeMixin
    implements ANPSPricesLoading {
  const _$ANPSPricesLoading({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.pricesLoading(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenState.pricesLoading'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ANPSPricesLoading &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$ANPSPricesLoadingCopyWith<_$ANPSPricesLoading> get copyWith =>
      __$$ANPSPricesLoadingCopyWithImpl<_$ANPSPricesLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return pricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return pricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return pricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return pricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesLoading != null) {
      return pricesLoading(this);
    }
    return orElse();
  }
}

abstract class ANPSPricesLoading implements AddNewPriceScreenState {
  const factory ANPSPricesLoading(
      {required final AddNewPriceScreenProps props}) = _$ANPSPricesLoading;

  @override
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ANPSPricesLoadingCopyWith<_$ANPSPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ANPSNextPricesLoadingCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory _$$ANPSNextPricesLoadingCopyWith(_$ANPSNextPricesLoading value,
          $Res Function(_$ANPSNextPricesLoading) then) =
      __$$ANPSNextPricesLoadingCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$ANPSNextPricesLoadingCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements _$$ANPSNextPricesLoadingCopyWith<$Res> {
  __$$ANPSNextPricesLoadingCopyWithImpl(_$ANPSNextPricesLoading _value,
      $Res Function(_$ANPSNextPricesLoading) _then)
      : super(_value, (v) => _then(v as _$ANPSNextPricesLoading));

  @override
  _$ANPSNextPricesLoading get _value => super._value as _$ANPSNextPricesLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$ANPSNextPricesLoading(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSNextPricesLoading
    with DiagnosticableTreeMixin
    implements ANPSNextPricesLoading {
  const _$ANPSNextPricesLoading({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.nextPricesLoading(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenState.nextPricesLoading'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ANPSNextPricesLoading &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$ANPSNextPricesLoadingCopyWith<_$ANPSNextPricesLoading> get copyWith =>
      __$$ANPSNextPricesLoadingCopyWithImpl<_$ANPSNextPricesLoading>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return nextPricesLoading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return nextPricesLoading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return nextPricesLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return nextPricesLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (nextPricesLoading != null) {
      return nextPricesLoading(this);
    }
    return orElse();
  }
}

abstract class ANPSNextPricesLoading implements AddNewPriceScreenState {
  const factory ANPSNextPricesLoading(
      {required final AddNewPriceScreenProps props}) = _$ANPSNextPricesLoading;

  @override
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ANPSNextPricesLoadingCopyWith<_$ANPSNextPricesLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ANPSPricesCompletedCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory _$$ANPSPricesCompletedCopyWith(_$ANPSPricesCompleted value,
          $Res Function(_$ANPSPricesCompleted) then) =
      __$$ANPSPricesCompletedCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$ANPSPricesCompletedCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements _$$ANPSPricesCompletedCopyWith<$Res> {
  __$$ANPSPricesCompletedCopyWithImpl(
      _$ANPSPricesCompleted _value, $Res Function(_$ANPSPricesCompleted) _then)
      : super(_value, (v) => _then(v as _$ANPSPricesCompleted));

  @override
  _$ANPSPricesCompleted get _value => super._value as _$ANPSPricesCompleted;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_$ANPSPricesCompleted(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSPricesCompleted
    with DiagnosticableTreeMixin
    implements ANPSPricesCompleted {
  const _$ANPSPricesCompleted({required this.props});

  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.pricesCompleted(props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(
          DiagnosticsProperty('type', 'AddNewPriceScreenState.pricesCompleted'))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ANPSPricesCompleted &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$ANPSPricesCompletedCopyWith<_$ANPSPricesCompleted> get copyWith =>
      __$$ANPSPricesCompletedCopyWithImpl<_$ANPSPricesCompleted>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return pricesCompleted(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return pricesCompleted?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return pricesCompleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return pricesCompleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesCompleted != null) {
      return pricesCompleted(this);
    }
    return orElse();
  }
}

abstract class ANPSPricesCompleted implements AddNewPriceScreenState {
  const factory ANPSPricesCompleted(
      {required final AddNewPriceScreenProps props}) = _$ANPSPricesCompleted;

  @override
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ANPSPricesCompletedCopyWith<_$ANPSPricesCompleted> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ANPSPricesErrorCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory _$$ANPSPricesErrorCopyWith(
          _$ANPSPricesError value, $Res Function(_$ANPSPricesError) then) =
      __$$ANPSPricesErrorCopyWithImpl<$Res>;
  @override
  $Res call(
      {String message,
      String code,
      StackTrace stackTrace,
      AddNewPriceScreenProps props});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$ANPSPricesErrorCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements _$$ANPSPricesErrorCopyWith<$Res> {
  __$$ANPSPricesErrorCopyWithImpl(
      _$ANPSPricesError _value, $Res Function(_$ANPSPricesError) _then)
      : super(_value, (v) => _then(v as _$ANPSPricesError));

  @override
  _$ANPSPricesError get _value => super._value as _$ANPSPricesError;

  @override
  $Res call({
    Object? message = freezed,
    Object? code = freezed,
    Object? stackTrace = freezed,
    Object? props = freezed,
  }) {
    return _then(_$ANPSPricesError(
      message: message == freezed
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      stackTrace: stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }
}

/// @nodoc

class _$ANPSPricesError
    with DiagnosticableTreeMixin
    implements ANPSPricesError {
  const _$ANPSPricesError(
      {required this.message,
      required this.code,
      required this.stackTrace,
      required this.props});

  @override
  final String message;
  @override
  final String code;
  @override
  final StackTrace stackTrace;
  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.pricesError(message: $message, code: $code, stackTrace: $stackTrace, props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenState.pricesError'))
      ..add(DiagnosticsProperty('message', message))
      ..add(DiagnosticsProperty('code', code))
      ..add(DiagnosticsProperty('stackTrace', stackTrace))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ANPSPricesError &&
            const DeepCollectionEquality().equals(other.message, message) &&
            const DeepCollectionEquality().equals(other.code, code) &&
            const DeepCollectionEquality()
                .equals(other.stackTrace, stackTrace) &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(message),
      const DeepCollectionEquality().hash(code),
      const DeepCollectionEquality().hash(stackTrace),
      const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$ANPSPricesErrorCopyWith<_$ANPSPricesError> get copyWith =>
      __$$ANPSPricesErrorCopyWithImpl<_$ANPSPricesError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return pricesError(message, code, stackTrace, props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return pricesError?.call(message, code, stackTrace, props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(message, code, stackTrace, props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return pricesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return pricesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (pricesError != null) {
      return pricesError(this);
    }
    return orElse();
  }
}

abstract class ANPSPricesError implements AddNewPriceScreenState {
  const factory ANPSPricesError(
      {required final String message,
      required final String code,
      required final StackTrace stackTrace,
      required final AddNewPriceScreenProps props}) = _$ANPSPricesError;

  String get message => throw _privateConstructorUsedError;
  String get code => throw _privateConstructorUsedError;
  StackTrace get stackTrace => throw _privateConstructorUsedError;
  @override
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ANPSPricesErrorCopyWith<_$ANPSPricesError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ANPSAddNewPriceSuccessCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory _$$ANPSAddNewPriceSuccessCopyWith(_$ANPSAddNewPriceSuccess value,
          $Res Function(_$ANPSAddNewPriceSuccess) then) =
      __$$ANPSAddNewPriceSuccessCopyWithImpl<$Res>;
  @override
  $Res call({Produce produce, AddNewPriceScreenProps props});

  $ProduceCopyWith<$Res> get produce;
  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$ANPSAddNewPriceSuccessCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements _$$ANPSAddNewPriceSuccessCopyWith<$Res> {
  __$$ANPSAddNewPriceSuccessCopyWithImpl(_$ANPSAddNewPriceSuccess _value,
      $Res Function(_$ANPSAddNewPriceSuccess) _then)
      : super(_value, (v) => _then(v as _$ANPSAddNewPriceSuccess));

  @override
  _$ANPSAddNewPriceSuccess get _value =>
      super._value as _$ANPSAddNewPriceSuccess;

  @override
  $Res call({
    Object? produce = freezed,
    Object? props = freezed,
  }) {
    return _then(_$ANPSAddNewPriceSuccess(
      produce: produce == freezed
          ? _value.produce
          : produce // ignore: cast_nullable_to_non_nullable
              as Produce,
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
    ));
  }

  @override
  $ProduceCopyWith<$Res> get produce {
    return $ProduceCopyWith<$Res>(_value.produce, (value) {
      return _then(_value.copyWith(produce: value));
    });
  }
}

/// @nodoc

class _$ANPSAddNewPriceSuccess
    with DiagnosticableTreeMixin
    implements ANPSAddNewPriceSuccess {
  const _$ANPSAddNewPriceSuccess({required this.produce, required this.props});

  @override
  final Produce produce;
  @override
  final AddNewPriceScreenProps props;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.addNewPriceSuccess(produce: $produce, props: $props)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenState.addNewPriceSuccess'))
      ..add(DiagnosticsProperty('produce', produce))
      ..add(DiagnosticsProperty('props', props));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ANPSAddNewPriceSuccess &&
            const DeepCollectionEquality().equals(other.produce, produce) &&
            const DeepCollectionEquality().equals(other.props, props));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(produce),
      const DeepCollectionEquality().hash(props));

  @JsonKey(ignore: true)
  @override
  _$$ANPSAddNewPriceSuccessCopyWith<_$ANPSAddNewPriceSuccess> get copyWith =>
      __$$ANPSAddNewPriceSuccessCopyWithImpl<_$ANPSAddNewPriceSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return addNewPriceSuccess(produce, props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return addNewPriceSuccess?.call(produce, props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceSuccess != null) {
      return addNewPriceSuccess(produce, props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return addNewPriceSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return addNewPriceSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceSuccess != null) {
      return addNewPriceSuccess(this);
    }
    return orElse();
  }
}

abstract class ANPSAddNewPriceSuccess implements AddNewPriceScreenState {
  const factory ANPSAddNewPriceSuccess(
      {required final Produce produce,
      required final AddNewPriceScreenProps props}) = _$ANPSAddNewPriceSuccess;

  Produce get produce => throw _privateConstructorUsedError;
  @override
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ANPSAddNewPriceSuccessCopyWith<_$ANPSAddNewPriceSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ANPSAddNewPriceErrorCopyWith<$Res>
    implements $AddNewPriceScreenStateCopyWith<$Res> {
  factory _$$ANPSAddNewPriceErrorCopyWith(_$ANPSAddNewPriceError value,
          $Res Function(_$ANPSAddNewPriceError) then) =
      __$$ANPSAddNewPriceErrorCopyWithImpl<$Res>;
  @override
  $Res call({AddNewPriceScreenProps props, Failure failure});

  @override
  $AddNewPriceScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$$ANPSAddNewPriceErrorCopyWithImpl<$Res>
    extends _$AddNewPriceScreenStateCopyWithImpl<$Res>
    implements _$$ANPSAddNewPriceErrorCopyWith<$Res> {
  __$$ANPSAddNewPriceErrorCopyWithImpl(_$ANPSAddNewPriceError _value,
      $Res Function(_$ANPSAddNewPriceError) _then)
      : super(_value, (v) => _then(v as _$ANPSAddNewPriceError));

  @override
  _$ANPSAddNewPriceError get _value => super._value as _$ANPSAddNewPriceError;

  @override
  $Res call({
    Object? props = freezed,
    Object? failure = freezed,
  }) {
    return _then(_$ANPSAddNewPriceError(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as AddNewPriceScreenProps,
      failure: failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure,
    ));
  }
}

/// @nodoc

class _$ANPSAddNewPriceError
    with DiagnosticableTreeMixin
    implements ANPSAddNewPriceError {
  const _$ANPSAddNewPriceError({required this.props, required this.failure});

  @override
  final AddNewPriceScreenProps props;
  @override
  final Failure failure;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenState.addNewPriceError(props: $props, failure: $failure)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty(
          'type', 'AddNewPriceScreenState.addNewPriceError'))
      ..add(DiagnosticsProperty('props', props))
      ..add(DiagnosticsProperty('failure', failure));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ANPSAddNewPriceError &&
            const DeepCollectionEquality().equals(other.props, props) &&
            const DeepCollectionEquality().equals(other.failure, failure));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(props),
      const DeepCollectionEquality().hash(failure));

  @JsonKey(ignore: true)
  @override
  _$$ANPSAddNewPriceErrorCopyWith<_$ANPSAddNewPriceError> get copyWith =>
      __$$ANPSAddNewPriceErrorCopyWithImpl<_$ANPSAddNewPriceError>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(AddNewPriceScreenProps props) initial,
    required TResult Function(AddNewPriceScreenProps props) pricesLoading,
    required TResult Function(AddNewPriceScreenProps props) nextPricesLoading,
    required TResult Function(AddNewPriceScreenProps props) pricesCompleted,
    required TResult Function(String message, String code,
            StackTrace stackTrace, AddNewPriceScreenProps props)
        pricesError,
    required TResult Function(Produce produce, AddNewPriceScreenProps props)
        addNewPriceSuccess,
    required TResult Function(AddNewPriceScreenProps props, Failure failure)
        addNewPriceError,
  }) {
    return addNewPriceError(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
  }) {
    return addNewPriceError?.call(props, failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(AddNewPriceScreenProps props)? initial,
    TResult Function(AddNewPriceScreenProps props)? pricesLoading,
    TResult Function(AddNewPriceScreenProps props)? nextPricesLoading,
    TResult Function(AddNewPriceScreenProps props)? pricesCompleted,
    TResult Function(String message, String code, StackTrace stackTrace,
            AddNewPriceScreenProps props)?
        pricesError,
    TResult Function(Produce produce, AddNewPriceScreenProps props)?
        addNewPriceSuccess,
    TResult Function(AddNewPriceScreenProps props, Failure failure)?
        addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceError != null) {
      return addNewPriceError(props, failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ANPSInitial value) initial,
    required TResult Function(ANPSPricesLoading value) pricesLoading,
    required TResult Function(ANPSNextPricesLoading value) nextPricesLoading,
    required TResult Function(ANPSPricesCompleted value) pricesCompleted,
    required TResult Function(ANPSPricesError value) pricesError,
    required TResult Function(ANPSAddNewPriceSuccess value) addNewPriceSuccess,
    required TResult Function(ANPSAddNewPriceError value) addNewPriceError,
  }) {
    return addNewPriceError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
  }) {
    return addNewPriceError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ANPSInitial value)? initial,
    TResult Function(ANPSPricesLoading value)? pricesLoading,
    TResult Function(ANPSNextPricesLoading value)? nextPricesLoading,
    TResult Function(ANPSPricesCompleted value)? pricesCompleted,
    TResult Function(ANPSPricesError value)? pricesError,
    TResult Function(ANPSAddNewPriceSuccess value)? addNewPriceSuccess,
    TResult Function(ANPSAddNewPriceError value)? addNewPriceError,
    required TResult orElse(),
  }) {
    if (addNewPriceError != null) {
      return addNewPriceError(this);
    }
    return orElse();
  }
}

abstract class ANPSAddNewPriceError implements AddNewPriceScreenState {
  const factory ANPSAddNewPriceError(
      {required final AddNewPriceScreenProps props,
      required final Failure failure}) = _$ANPSAddNewPriceError;

  @override
  AddNewPriceScreenProps get props => throw _privateConstructorUsedError;
  Failure get failure => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ANPSAddNewPriceErrorCopyWith<_$ANPSAddNewPriceError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddNewPriceScreenProps {
  List<Produce> get produceList => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddNewPriceScreenPropsCopyWith<AddNewPriceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddNewPriceScreenPropsCopyWith<$Res> {
  factory $AddNewPriceScreenPropsCopyWith(AddNewPriceScreenProps value,
          $Res Function(AddNewPriceScreenProps) then) =
      _$AddNewPriceScreenPropsCopyWithImpl<$Res>;
  $Res call({List<Produce> produceList});
}

/// @nodoc
class _$AddNewPriceScreenPropsCopyWithImpl<$Res>
    implements $AddNewPriceScreenPropsCopyWith<$Res> {
  _$AddNewPriceScreenPropsCopyWithImpl(this._value, this._then);

  final AddNewPriceScreenProps _value;
  // ignore: unused_field
  final $Res Function(AddNewPriceScreenProps) _then;

  @override
  $Res call({
    Object? produceList = freezed,
  }) {
    return _then(_value.copyWith(
      produceList: produceList == freezed
          ? _value.produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
    ));
  }
}

/// @nodoc
abstract class _$$_AddNewPriceScreenPropsCopyWith<$Res>
    implements $AddNewPriceScreenPropsCopyWith<$Res> {
  factory _$$_AddNewPriceScreenPropsCopyWith(_$_AddNewPriceScreenProps value,
          $Res Function(_$_AddNewPriceScreenProps) then) =
      __$$_AddNewPriceScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call({List<Produce> produceList});
}

/// @nodoc
class __$$_AddNewPriceScreenPropsCopyWithImpl<$Res>
    extends _$AddNewPriceScreenPropsCopyWithImpl<$Res>
    implements _$$_AddNewPriceScreenPropsCopyWith<$Res> {
  __$$_AddNewPriceScreenPropsCopyWithImpl(_$_AddNewPriceScreenProps _value,
      $Res Function(_$_AddNewPriceScreenProps) _then)
      : super(_value, (v) => _then(v as _$_AddNewPriceScreenProps));

  @override
  _$_AddNewPriceScreenProps get _value =>
      super._value as _$_AddNewPriceScreenProps;

  @override
  $Res call({
    Object? produceList = freezed,
  }) {
    return _then(_$_AddNewPriceScreenProps(
      produceList: produceList == freezed
          ? _value._produceList
          : produceList // ignore: cast_nullable_to_non_nullable
              as List<Produce>,
    ));
  }
}

/// @nodoc

class _$_AddNewPriceScreenProps
    with DiagnosticableTreeMixin
    implements _AddNewPriceScreenProps {
  const _$_AddNewPriceScreenProps({required final List<Produce> produceList})
      : _produceList = produceList;

  final List<Produce> _produceList;
  @override
  List<Produce> get produceList {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_produceList);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AddNewPriceScreenProps(produceList: $produceList)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AddNewPriceScreenProps'))
      ..add(DiagnosticsProperty('produceList', produceList));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AddNewPriceScreenProps &&
            const DeepCollectionEquality()
                .equals(other._produceList, _produceList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_produceList));

  @JsonKey(ignore: true)
  @override
  _$$_AddNewPriceScreenPropsCopyWith<_$_AddNewPriceScreenProps> get copyWith =>
      __$$_AddNewPriceScreenPropsCopyWithImpl<_$_AddNewPriceScreenProps>(
          this, _$identity);
}

abstract class _AddNewPriceScreenProps implements AddNewPriceScreenProps {
  const factory _AddNewPriceScreenProps(
      {required final List<Produce> produceList}) = _$_AddNewPriceScreenProps;

  @override
  List<Produce> get produceList => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AddNewPriceScreenPropsCopyWith<_$_AddNewPriceScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'login_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LoginScreenEventTearOff {
  const _$LoginScreenEventTearOff();

  _LSEStarted started() {
    return const _LSEStarted();
  }

  _LSEIdle idle() {
    return const _LSEIdle();
  }

  _LSEContinuePressed continuePressed() {
    return const _LSEContinuePressed();
  }

  _LSEToggleVisible toggleInfoTileVisibility() {
    return const _LSEToggleVisible();
  }
}

/// @nodoc
const $LoginScreenEvent = _$LoginScreenEventTearOff();

/// @nodoc
mixin _$LoginScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSEStarted value) started,
    required TResult Function(_LSEIdle value) idle,
    required TResult Function(_LSEContinuePressed value) continuePressed,
    required TResult Function(_LSEToggleVisible value) toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginScreenEventCopyWith<$Res> {
  factory $LoginScreenEventCopyWith(
          LoginScreenEvent value, $Res Function(LoginScreenEvent) then) =
      _$LoginScreenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginScreenEventCopyWithImpl<$Res>
    implements $LoginScreenEventCopyWith<$Res> {
  _$LoginScreenEventCopyWithImpl(this._value, this._then);

  final LoginScreenEvent _value;
  // ignore: unused_field
  final $Res Function(LoginScreenEvent) _then;
}

/// @nodoc
abstract class _$LSEStartedCopyWith<$Res> {
  factory _$LSEStartedCopyWith(
          _LSEStarted value, $Res Function(_LSEStarted) then) =
      __$LSEStartedCopyWithImpl<$Res>;
}

/// @nodoc
class __$LSEStartedCopyWithImpl<$Res>
    extends _$LoginScreenEventCopyWithImpl<$Res>
    implements _$LSEStartedCopyWith<$Res> {
  __$LSEStartedCopyWithImpl(
      _LSEStarted _value, $Res Function(_LSEStarted) _then)
      : super(_value, (v) => _then(v as _LSEStarted));

  @override
  _LSEStarted get _value => super._value as _LSEStarted;
}

/// @nodoc

class _$_LSEStarted implements _LSEStarted {
  const _$_LSEStarted();

  @override
  String toString() {
    return 'LoginScreenEvent.started()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LSEStarted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSEStarted value) started,
    required TResult Function(_LSEIdle value) idle,
    required TResult Function(_LSEContinuePressed value) continuePressed,
    required TResult Function(_LSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _LSEStarted implements LoginScreenEvent {
  const factory _LSEStarted() = _$_LSEStarted;
}

/// @nodoc
abstract class _$LSEIdleCopyWith<$Res> {
  factory _$LSEIdleCopyWith(_LSEIdle value, $Res Function(_LSEIdle) then) =
      __$LSEIdleCopyWithImpl<$Res>;
}

/// @nodoc
class __$LSEIdleCopyWithImpl<$Res> extends _$LoginScreenEventCopyWithImpl<$Res>
    implements _$LSEIdleCopyWith<$Res> {
  __$LSEIdleCopyWithImpl(_LSEIdle _value, $Res Function(_LSEIdle) _then)
      : super(_value, (v) => _then(v as _LSEIdle));

  @override
  _LSEIdle get _value => super._value as _LSEIdle;
}

/// @nodoc

class _$_LSEIdle implements _LSEIdle {
  const _$_LSEIdle();

  @override
  String toString() {
    return 'LoginScreenEvent.idle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LSEIdle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSEStarted value) started,
    required TResult Function(_LSEIdle value) idle,
    required TResult Function(_LSEContinuePressed value) continuePressed,
    required TResult Function(_LSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _LSEIdle implements LoginScreenEvent {
  const factory _LSEIdle() = _$_LSEIdle;
}

/// @nodoc
abstract class _$LSEContinuePressedCopyWith<$Res> {
  factory _$LSEContinuePressedCopyWith(
          _LSEContinuePressed value, $Res Function(_LSEContinuePressed) then) =
      __$LSEContinuePressedCopyWithImpl<$Res>;
}

/// @nodoc
class __$LSEContinuePressedCopyWithImpl<$Res>
    extends _$LoginScreenEventCopyWithImpl<$Res>
    implements _$LSEContinuePressedCopyWith<$Res> {
  __$LSEContinuePressedCopyWithImpl(
      _LSEContinuePressed _value, $Res Function(_LSEContinuePressed) _then)
      : super(_value, (v) => _then(v as _LSEContinuePressed));

  @override
  _LSEContinuePressed get _value => super._value as _LSEContinuePressed;
}

/// @nodoc

class _$_LSEContinuePressed implements _LSEContinuePressed {
  const _$_LSEContinuePressed();

  @override
  String toString() {
    return 'LoginScreenEvent.continuePressed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LSEContinuePressed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return continuePressed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return continuePressed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (continuePressed != null) {
      return continuePressed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSEStarted value) started,
    required TResult Function(_LSEIdle value) idle,
    required TResult Function(_LSEContinuePressed value) continuePressed,
    required TResult Function(_LSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return continuePressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return continuePressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (continuePressed != null) {
      return continuePressed(this);
    }
    return orElse();
  }
}

abstract class _LSEContinuePressed implements LoginScreenEvent {
  const factory _LSEContinuePressed() = _$_LSEContinuePressed;
}

/// @nodoc
abstract class _$LSEToggleVisibleCopyWith<$Res> {
  factory _$LSEToggleVisibleCopyWith(
          _LSEToggleVisible value, $Res Function(_LSEToggleVisible) then) =
      __$LSEToggleVisibleCopyWithImpl<$Res>;
}

/// @nodoc
class __$LSEToggleVisibleCopyWithImpl<$Res>
    extends _$LoginScreenEventCopyWithImpl<$Res>
    implements _$LSEToggleVisibleCopyWith<$Res> {
  __$LSEToggleVisibleCopyWithImpl(
      _LSEToggleVisible _value, $Res Function(_LSEToggleVisible) _then)
      : super(_value, (v) => _then(v as _LSEToggleVisible));

  @override
  _LSEToggleVisible get _value => super._value as _LSEToggleVisible;
}

/// @nodoc

class _$_LSEToggleVisible implements _LSEToggleVisible {
  const _$_LSEToggleVisible();

  @override
  String toString() {
    return 'LoginScreenEvent.toggleInfoTileVisibility()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LSEToggleVisible);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() idle,
    required TResult Function() continuePressed,
    required TResult Function() toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? idle,
    TResult Function()? continuePressed,
    TResult Function()? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (toggleInfoTileVisibility != null) {
      return toggleInfoTileVisibility();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSEStarted value) started,
    required TResult Function(_LSEIdle value) idle,
    required TResult Function(_LSEContinuePressed value) continuePressed,
    required TResult Function(_LSEToggleVisible value) toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
  }) {
    return toggleInfoTileVisibility?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSEStarted value)? started,
    TResult Function(_LSEIdle value)? idle,
    TResult Function(_LSEContinuePressed value)? continuePressed,
    TResult Function(_LSEToggleVisible value)? toggleInfoTileVisibility,
    required TResult orElse(),
  }) {
    if (toggleInfoTileVisibility != null) {
      return toggleInfoTileVisibility(this);
    }
    return orElse();
  }
}

abstract class _LSEToggleVisible implements LoginScreenEvent {
  const factory _LSEToggleVisible() = _$_LSEToggleVisible;
}

/// @nodoc
class _$LoginScreenStateTearOff {
  const _$LoginScreenStateTearOff();

  _LSSInitial initial(LoginScreenProps props) {
    return _LSSInitial(
      props,
    );
  }

  _LSSLoading loading(LoginScreenProps props) {
    return _LSSLoading(
      props,
    );
  }

  _LSSIdle idle(LoginScreenProps props) {
    return _LSSIdle(
      props,
    );
  }
}

/// @nodoc
const $LoginScreenState = _$LoginScreenStateTearOff();

/// @nodoc
mixin _$LoginScreenState {
  LoginScreenProps get props => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginScreenProps props) initial,
    required TResult Function(LoginScreenProps props) loading,
    required TResult Function(LoginScreenProps props) idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSSInitial value) initial,
    required TResult Function(_LSSLoading value) loading,
    required TResult Function(_LSSIdle value) idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LoginScreenStateCopyWith<LoginScreenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginScreenStateCopyWith<$Res> {
  factory $LoginScreenStateCopyWith(
          LoginScreenState value, $Res Function(LoginScreenState) then) =
      _$LoginScreenStateCopyWithImpl<$Res>;
  $Res call({LoginScreenProps props});

  $LoginScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class _$LoginScreenStateCopyWithImpl<$Res>
    implements $LoginScreenStateCopyWith<$Res> {
  _$LoginScreenStateCopyWithImpl(this._value, this._then);

  final LoginScreenState _value;
  // ignore: unused_field
  final $Res Function(LoginScreenState) _then;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_value.copyWith(
      props: props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as LoginScreenProps,
    ));
  }

  @override
  $LoginScreenPropsCopyWith<$Res> get props {
    return $LoginScreenPropsCopyWith<$Res>(_value.props, (value) {
      return _then(_value.copyWith(props: value));
    });
  }
}

/// @nodoc
abstract class _$LSSInitialCopyWith<$Res>
    implements $LoginScreenStateCopyWith<$Res> {
  factory _$LSSInitialCopyWith(
          _LSSInitial value, $Res Function(_LSSInitial) then) =
      __$LSSInitialCopyWithImpl<$Res>;
  @override
  $Res call({LoginScreenProps props});

  @override
  $LoginScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$LSSInitialCopyWithImpl<$Res>
    extends _$LoginScreenStateCopyWithImpl<$Res>
    implements _$LSSInitialCopyWith<$Res> {
  __$LSSInitialCopyWithImpl(
      _LSSInitial _value, $Res Function(_LSSInitial) _then)
      : super(_value, (v) => _then(v as _LSSInitial));

  @override
  _LSSInitial get _value => super._value as _LSSInitial;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_LSSInitial(
      props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as LoginScreenProps,
    ));
  }
}

/// @nodoc

class _$_LSSInitial implements _LSSInitial {
  const _$_LSSInitial(this.props);

  @override
  final LoginScreenProps props;

  @override
  String toString() {
    return 'LoginScreenState.initial(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LSSInitial &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$LSSInitialCopyWith<_LSSInitial> get copyWith =>
      __$LSSInitialCopyWithImpl<_LSSInitial>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginScreenProps props) initial,
    required TResult Function(LoginScreenProps props) loading,
    required TResult Function(LoginScreenProps props) idle,
  }) {
    return initial(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
  }) {
    return initial?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSSInitial value) initial,
    required TResult Function(_LSSLoading value) loading,
    required TResult Function(_LSSIdle value) idle,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _LSSInitial implements LoginScreenState {
  const factory _LSSInitial(LoginScreenProps props) = _$_LSSInitial;

  @override
  LoginScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$LSSInitialCopyWith<_LSSInitial> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$LSSLoadingCopyWith<$Res>
    implements $LoginScreenStateCopyWith<$Res> {
  factory _$LSSLoadingCopyWith(
          _LSSLoading value, $Res Function(_LSSLoading) then) =
      __$LSSLoadingCopyWithImpl<$Res>;
  @override
  $Res call({LoginScreenProps props});

  @override
  $LoginScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$LSSLoadingCopyWithImpl<$Res>
    extends _$LoginScreenStateCopyWithImpl<$Res>
    implements _$LSSLoadingCopyWith<$Res> {
  __$LSSLoadingCopyWithImpl(
      _LSSLoading _value, $Res Function(_LSSLoading) _then)
      : super(_value, (v) => _then(v as _LSSLoading));

  @override
  _LSSLoading get _value => super._value as _LSSLoading;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_LSSLoading(
      props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as LoginScreenProps,
    ));
  }
}

/// @nodoc

class _$_LSSLoading implements _LSSLoading {
  const _$_LSSLoading(this.props);

  @override
  final LoginScreenProps props;

  @override
  String toString() {
    return 'LoginScreenState.loading(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LSSLoading &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$LSSLoadingCopyWith<_LSSLoading> get copyWith =>
      __$LSSLoadingCopyWithImpl<_LSSLoading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginScreenProps props) initial,
    required TResult Function(LoginScreenProps props) loading,
    required TResult Function(LoginScreenProps props) idle,
  }) {
    return loading(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
  }) {
    return loading?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSSInitial value) initial,
    required TResult Function(_LSSLoading value) loading,
    required TResult Function(_LSSIdle value) idle,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _LSSLoading implements LoginScreenState {
  const factory _LSSLoading(LoginScreenProps props) = _$_LSSLoading;

  @override
  LoginScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$LSSLoadingCopyWith<_LSSLoading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$LSSIdleCopyWith<$Res>
    implements $LoginScreenStateCopyWith<$Res> {
  factory _$LSSIdleCopyWith(_LSSIdle value, $Res Function(_LSSIdle) then) =
      __$LSSIdleCopyWithImpl<$Res>;
  @override
  $Res call({LoginScreenProps props});

  @override
  $LoginScreenPropsCopyWith<$Res> get props;
}

/// @nodoc
class __$LSSIdleCopyWithImpl<$Res> extends _$LoginScreenStateCopyWithImpl<$Res>
    implements _$LSSIdleCopyWith<$Res> {
  __$LSSIdleCopyWithImpl(_LSSIdle _value, $Res Function(_LSSIdle) _then)
      : super(_value, (v) => _then(v as _LSSIdle));

  @override
  _LSSIdle get _value => super._value as _LSSIdle;

  @override
  $Res call({
    Object? props = freezed,
  }) {
    return _then(_LSSIdle(
      props == freezed
          ? _value.props
          : props // ignore: cast_nullable_to_non_nullable
              as LoginScreenProps,
    ));
  }
}

/// @nodoc

class _$_LSSIdle implements _LSSIdle {
  const _$_LSSIdle(this.props);

  @override
  final LoginScreenProps props;

  @override
  String toString() {
    return 'LoginScreenState.idle(props: $props)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LSSIdle &&
            (identical(other.props, props) || other.props == props));
  }

  @override
  int get hashCode => Object.hash(runtimeType, props);

  @JsonKey(ignore: true)
  @override
  _$LSSIdleCopyWith<_LSSIdle> get copyWith =>
      __$LSSIdleCopyWithImpl<_LSSIdle>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginScreenProps props) initial,
    required TResult Function(LoginScreenProps props) loading,
    required TResult Function(LoginScreenProps props) idle,
  }) {
    return idle(props);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
  }) {
    return idle?.call(props);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginScreenProps props)? initial,
    TResult Function(LoginScreenProps props)? loading,
    TResult Function(LoginScreenProps props)? idle,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(props);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LSSInitial value) initial,
    required TResult Function(_LSSLoading value) loading,
    required TResult Function(_LSSIdle value) idle,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LSSInitial value)? initial,
    TResult Function(_LSSLoading value)? loading,
    TResult Function(_LSSIdle value)? idle,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _LSSIdle implements LoginScreenState {
  const factory _LSSIdle(LoginScreenProps props) = _$_LSSIdle;

  @override
  LoginScreenProps get props;
  @override
  @JsonKey(ignore: true)
  _$LSSIdleCopyWith<_LSSIdle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$LoginScreenPropsTearOff {
  const _$LoginScreenPropsTearOff();

  _LoginScreenProps call({required bool isInfoTileVisible}) {
    return _LoginScreenProps(
      isInfoTileVisible: isInfoTileVisible,
    );
  }
}

/// @nodoc
const $LoginScreenProps = _$LoginScreenPropsTearOff();

/// @nodoc
mixin _$LoginScreenProps {
  bool get isInfoTileVisible => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LoginScreenPropsCopyWith<LoginScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginScreenPropsCopyWith<$Res> {
  factory $LoginScreenPropsCopyWith(
          LoginScreenProps value, $Res Function(LoginScreenProps) then) =
      _$LoginScreenPropsCopyWithImpl<$Res>;
  $Res call({bool isInfoTileVisible});
}

/// @nodoc
class _$LoginScreenPropsCopyWithImpl<$Res>
    implements $LoginScreenPropsCopyWith<$Res> {
  _$LoginScreenPropsCopyWithImpl(this._value, this._then);

  final LoginScreenProps _value;
  // ignore: unused_field
  final $Res Function(LoginScreenProps) _then;

  @override
  $Res call({
    Object? isInfoTileVisible = freezed,
  }) {
    return _then(_value.copyWith(
      isInfoTileVisible: isInfoTileVisible == freezed
          ? _value.isInfoTileVisible
          : isInfoTileVisible // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$LoginScreenPropsCopyWith<$Res>
    implements $LoginScreenPropsCopyWith<$Res> {
  factory _$LoginScreenPropsCopyWith(
          _LoginScreenProps value, $Res Function(_LoginScreenProps) then) =
      __$LoginScreenPropsCopyWithImpl<$Res>;
  @override
  $Res call({bool isInfoTileVisible});
}

/// @nodoc
class __$LoginScreenPropsCopyWithImpl<$Res>
    extends _$LoginScreenPropsCopyWithImpl<$Res>
    implements _$LoginScreenPropsCopyWith<$Res> {
  __$LoginScreenPropsCopyWithImpl(
      _LoginScreenProps _value, $Res Function(_LoginScreenProps) _then)
      : super(_value, (v) => _then(v as _LoginScreenProps));

  @override
  _LoginScreenProps get _value => super._value as _LoginScreenProps;

  @override
  $Res call({
    Object? isInfoTileVisible = freezed,
  }) {
    return _then(_LoginScreenProps(
      isInfoTileVisible: isInfoTileVisible == freezed
          ? _value.isInfoTileVisible
          : isInfoTileVisible // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_LoginScreenProps implements _LoginScreenProps {
  const _$_LoginScreenProps({required this.isInfoTileVisible});

  @override
  final bool isInfoTileVisible;

  @override
  String toString() {
    return 'LoginScreenProps(isInfoTileVisible: $isInfoTileVisible)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _LoginScreenProps &&
            (identical(other.isInfoTileVisible, isInfoTileVisible) ||
                other.isInfoTileVisible == isInfoTileVisible));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isInfoTileVisible);

  @JsonKey(ignore: true)
  @override
  _$LoginScreenPropsCopyWith<_LoginScreenProps> get copyWith =>
      __$LoginScreenPropsCopyWithImpl<_LoginScreenProps>(this, _$identity);
}

abstract class _LoginScreenProps implements LoginScreenProps {
  const factory _LoginScreenProps({required bool isInfoTileVisible}) =
      _$_LoginScreenProps;

  @override
  bool get isInfoTileVisible;
  @override
  @JsonKey(ignore: true)
  _$LoginScreenPropsCopyWith<_LoginScreenProps> get copyWith =>
      throw _privateConstructorUsedError;
}
